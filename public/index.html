<!DOCTYPE html>
<!--
UI ACCEPTANCE CHECKLIST ‚Äî SEASON MANAGER

- UI is read-only by default
- No lifecycle configuration controls
- No Start/Reset buttons
- No duration inputs
- Emergency actions are collapsed and explicit
- Phase is displayed
- Backend remains authoritative
-->
<html lang="en">
<head>
	<meta charset="UTF-8" />
	<meta name="viewport" content="width=device-width, initial-scale=1" />
	<title>Too Many Coins</title>
	<style>
	:root {
		color-scheme: dark;
		--bg: #0b0f1d;
		--panel: #141a2e;
		--panel-strong: #1a2140;
		--border: #2a2f55;
		--text: #eaeaf0;
		--muted: #9aa3c4;
		--accent: #3b82f6;
		--success: #22c55e;
		--warning: #f59e0b;
		--danger: #ef4444;
	}
	body {
	.badge.warn {
		background: #f59e0b;
		color: #2a1b00;
	}
		font-family: "Inter", system-ui, sans-serif;
		background: radial-gradient(circle at top, #151c35 0%, #0b0f1d 45%, #060814 100%);
		color: var(--text);
		margin: 0;
		min-height: 100vh;
		display: flex;
		flex-direction: column;
	}
	header {
		position: sticky;
		top: 0;
		z-index: 15;
		display: flex;
		align-items: center;
		justify-content: space-between;
		gap: 1.5rem;
		padding: 1.25rem 2rem;
		background: rgba(8, 12, 26, 0.92);
		backdrop-filter: blur(12px);
		border-bottom: 1px solid var(--border);
	}
	main {
		padding: 2rem;
		max-width: 1200px;
		width: 100%;
		margin: 0 auto;
		box-sizing: border-box;
	}
	.app-title {
		display: flex;
		align-items: center;
		gap: 1rem;
	}
	.app-mark {
		width: 42px;
		height: 42px;
		border-radius: 14px;
		background: linear-gradient(135deg, #3b82f6, #6366f1);
		display: grid;
		place-items: center;
		font-weight: 700;
		color: white;
		box-shadow: 0 12px 24px rgba(59, 130, 246, 0.35);
	}
	.app-actions {
		display: flex;
		flex-direction: column;
		align-items: flex-end;
		gap: 0.65rem;
	}
	.nav-links a {
		color: #c5cae9;
		text-decoration: none;
		margin-left: 0.75rem;
		font-size: 0.85rem;
	}
	.live-status {
		display: inline-flex;
		align-items: center;
		gap: 0.4rem;
		font-size: 0.75rem;
		padding: 0.25rem 0.5rem;
		border-radius: 999px;
		border: 1px solid rgba(34, 197, 94, 0.5);
		color: #bbf7d0;
		background: rgba(34, 197, 94, 0.12);
	}
	.live-status::before {
		content: "";
		width: 6px;
		height: 6px;
		border-radius: 999px;
		background: #22c55e;
		box-shadow: 0 0 8px rgba(34, 197, 94, 0.8);
	}
	.live-status.offline {
		border-color: rgba(239, 68, 68, 0.5);
		color: #fecaca;
		background: rgba(239, 68, 68, 0.12);
	}
	.live-status.offline::before {
		background: #ef4444;
		box-shadow: 0 0 8px rgba(239, 68, 68, 0.8);
	}
	.live-status.reconnecting {
		border-color: rgba(245, 158, 11, 0.5);
		color: #fde68a;
		background: rgba(245, 158, 11, 0.12);
	}
	.live-status.reconnecting::before {
		background: #f59e0b;
		box-shadow: 0 0 8px rgba(245, 158, 11, 0.8);
	}
	.badge {
		font-size: 0.75rem;
		padding: 0.25rem 0.5rem;
		border-radius: 999px;
		background: #1f2544;
		border: 1px solid #2a2f55;
	}
	.badge.accent {
		background: rgba(59, 130, 246, 0.15);
		border-color: rgba(59, 130, 246, 0.5);
		color: #93c5fd;
	}
	.badge.bot {
		background: rgba(248, 113, 113, 0.15);
		border-color: rgba(248, 113, 113, 0.5);
		color: #fecaca;
	}
	.card {
		border: 1px solid var(--border);
		padding: 1.25rem;
		margin-bottom: 1rem;
		border-radius: 16px;
		background: var(--panel);
		box-shadow: 0 18px 30px rgba(0, 0, 0, 0.25);
	}
	.card-header {
		display: flex;
		align-items: center;
		justify-content: space-between;
		gap: 1rem;
		margin-bottom: 1rem;
	}
	.hero-card {
		background: linear-gradient(140deg, rgba(59, 130, 246, 0.2), rgba(20, 26, 46, 0.95));
		border-color: rgba(59, 130, 246, 0.5);
	}
	.hero-grid {
		display: grid;
		grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
		gap: 1.5rem;
	}
	.metric-grid {
		display: grid;
		grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
		gap: 0.9rem;
	}
	.metric {
		padding: 0.75rem 0.9rem;
		background: rgba(10, 14, 28, 0.6);
		border-radius: 12px;
		border: 1px solid rgba(42, 47, 85, 0.8);
	}
	.stat-value {
		font-size: 1.1rem;
		font-weight: 600;
	}
	.dashboard-grid {
		display: grid;
		grid-template-columns: minmax(0, 2fr) minmax(0, 1fr);
		gap: 1.5rem;
		align-items: start;
	}
	.dashboard-main {
		display: flex;
		flex-direction: column;
		gap: 1rem;
	}
	.dashboard-side {
		display: flex;
		flex-direction: column;
		gap: 1rem;
	}
	.season-card {
		display: flex;
		flex-direction: column;
		gap: 1rem;
	}
	.season-card-header {
		display: flex;
		align-items: center;
		justify-content: space-between;
		gap: 1rem;
	}
	.season-card-grid {
		display: grid;
		grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
		gap: 0.75rem;
	}
	.season-actions {
		display: flex;
		gap: 0.5rem;
		flex-wrap: wrap;
	}
	.section-stack {
		display: flex;
		flex-direction: column;
		gap: 1rem;
	}
	.section-nav {
		display: flex;
		flex-wrap: wrap;
		gap: 0.75rem;
		font-size: 0.85rem;
	}
	.section-nav a {
		color: #c5cae9;
		text-decoration: none;
	}
	.split-grid {
		display: grid;
		grid-template-columns: repeat(auto-fit, minmax(260px, 1fr));
		gap: 1rem;
	}
	.card-toggle {
		display: flex;
		align-items: center;
		justify-content: space-between;
		gap: 0.75rem;
	}
	.card-toggle .label {
		font-size: 0.9rem;
		color: #c5cae9;
	}
	.card-body {
		margin-top: 0.75rem;
	}
	.card.collapsed .card-body {
		display: none;
	}
	.recommended {
		border-color: #ffd166;
		background: rgba(255, 209, 102, 0.08);
	}
	.label {
		font-size: 0.8rem;
		color: #aaa;
	}
	input, textarea, button {
		background: #0f1220;
		border: 1px solid #2a2f55;
		color: #eaeaf0;
		padding: 0.5rem 0.75rem;
		border-radius: 8px;
	}
	button {
		cursor: pointer;
	}
	button.primary {
		background: #3b82f6;
		border-color: #3b82f6;
	}
	button.danger {
		background: var(--danger);
		border-color: var(--danger);
	}
	.row {
		display: flex;
		align-items: center;
		gap: 0.75rem;
		flex-wrap: wrap;
	}
	.stack {
		display: flex;
		flex-direction: column;
		gap: 0.5rem;
	}
	.toast {
		padding: 0.6rem 0.8rem;
		border-radius: 8px;
		background: #11162b;
		border: 1px solid #2a2f55;
		font-size: 0.85rem;
	}
	.toast.error {
		border-color: #ef4444;
		color: #fecaca;
	}
	.toast.success {
		border-color: #22c55e;
		color: #bbf7d0;
	}
	.muted {
		color: #9aa3c4;
		font-size: 0.8rem;
	}
	.grid {
		display: grid;
		grid-template-columns: repeat(auto-fit, minmax(240px, 1fr));
		gap: 1rem;
	}
	.notice {
		padding: 0.75rem 1rem;
		border-radius: 10px;
		border: 1px solid #2a2f55;
		background: #11162b;
		margin-bottom: 0.5rem;
		display: flex;
		align-items: center;
		justify-content: space-between;
		gap: 1rem;
	}
	.notice.info { border-color: #2a2f55; }
	.notice.warn { border-color: #f59e0b; color: #fde68a; }
	.notice.urgent { border-color: #ef4444; color: #fecaca; }
	.notice.priority-high { border-color: #f59e0b; color: #fde68a; }
	.notice.priority-critical { border-color: #ef4444; color: #fecaca; box-shadow: 0 0 0 1px rgba(239, 68, 68, 0.35), 0 0 24px rgba(239, 68, 68, 0.2); }
	.notice button { padding: 0.25rem 0.6rem; }
	.notice.read {
		opacity: 0.55;
		filter: saturate(0.7);
	}
	.notice.unread {
		box-shadow: 0 0 0 1px rgba(59, 130, 246, 0.45), 0 0 18px rgba(59, 130, 246, 0.15);
	}
	.notice.clickable { cursor: pointer; }
	.notice .notice-content { flex: 1; }
	.notice .notice-meta {
		margin-top: 0.35rem;
		display: flex;
		flex-wrap: wrap;
		gap: 0.35rem;
		align-items: center;
	}
	.notice .notice-actions { display: flex; gap: 0.4rem; align-items: center; }
	.notice .notice-actions button { font-size: 0.75rem; }
	.notice .badge.subtle {
		background: #1e2647;
		color: #cbd5f5;
		border: 1px solid #2a2f55;
	}
	.notification-bell {
		position: fixed;
		right: 1.5rem;
		bottom: 1.5rem;
		width: 48px;
		height: 48px;
		border-radius: 999px;
		background: #1a2140;
		border: 1px solid #2a2f55;
		display: grid;
		place-items: center;
		cursor: pointer;
		z-index: 30;
		box-shadow: 0 18px 28px rgba(0, 0, 0, 0.35);
	}
	.notification-bell-icon {
		font-size: 1.1rem;
	}
	.notification-badge {
		position: absolute;
		top: -4px;
		right: -4px;
		min-width: 18px;
		height: 18px;
		padding: 0 6px;
		border-radius: 999px;
		background: #ef4444;
		color: #fff;
		font-size: 0.7rem;
		display: inline-flex;
		align-items: center;
		justify-content: center;
		border: 1px solid rgba(0, 0, 0, 0.3);
	}
	.notification-viewport {
		position: fixed;
		right: 1.5rem;
		bottom: 4.75rem;
		width: min(380px, 92vw);
		max-height: 70vh;
		overflow: auto;
		padding: 0.9rem;
		border-radius: 14px;
		background: #141a2e;
		border: 1px solid #2a2f55;
		box-shadow: 0 24px 44px rgba(0,0,0,0.4);
		z-index: 29;
	}
	.notification-list {
		display: flex;
		flex-direction: column;
		gap: 0.45rem;
		margin-top: 0.65rem;
	}
	.notification-item {
		display: flex;
		align-items: center;
		gap: 0.65rem;
		padding: 0.55rem 0.65rem;
		border-radius: 10px;
		border: 1px solid #242a4d;
		background: #101735;
		cursor: pointer;
		transition: border-color 0.2s ease, background 0.2s ease;
	}
	.notification-item.unread {
		background: #172144;
		border-color: rgba(59, 130, 246, 0.5);
	}
	.notification-item.read {
		opacity: 0.6;
	}
	.notification-icon {
		width: 28px;
		height: 28px;
		border-radius: 8px;
		background: #1f2544;
		display: grid;
		place-items: center;
		font-size: 0.9rem;
		color: #cbd5f5;
		flex-shrink: 0;
	}
	.notification-body {
		display: flex;
		flex-direction: column;
		gap: 0.15rem;
		flex: 1;
		min-width: 0;
	}
	.notification-message {
		font-size: 0.85rem;
		line-height: 1.2;
		color: #e2e8f0;
	}
	.notification-time {
		font-size: 0.7rem;
		color: #9aa3c4;
	}
	.notification-trash {
		margin-left: auto;
		background: transparent;
		border: none;
		color: #94a3b8;
		opacity: 0;
		cursor: pointer;
		font-size: 0.9rem;
		padding: 0.2rem;
	}
	.notification-item:hover .notification-trash {
		opacity: 1;
	}
	.notification-empty {
		color: #9aa3c4;
		font-size: 0.8rem;
		padding: 0.4rem;
	}
	.notification-settings {
		margin-top: 0.75rem;
		padding-top: 0.75rem;
		border-top: 1px solid #232a4e;
	}
	.notification-settings-list {
		display: flex;
		flex-direction: column;
		gap: 0.45rem;
		margin-top: 0.5rem;
	}
	.notification-setting-row {
		display: grid;
		grid-template-columns: 1fr auto auto;
		gap: 0.5rem;
		align-items: center;
		padding: 0.4rem 0.5rem;
		border-radius: 8px;
		background: #101735;
		border: 1px solid #262c54;
	}
	.notification-setting-row label {
		display: inline-flex;
		align-items: center;
		gap: 0.35rem;
		font-size: 0.75rem;
		color: #cbd5f5;
	}
	.notification-controls {
		margin-top: 0.75rem;
		padding: 0.75rem;
		border-radius: 10px;
		background: #0f1426;
		border: 1px solid #242a4d;
	}
	.notification-controls select {
		background: #0f1426;
		color: #e2e8ff;
		border: 1px solid #2a2f55;
		border-radius: 6px;
		padding: 0.35rem 0.5rem;
	}
	.notification-toggle {
		display: flex;
		justify-content: space-between;
		align-items: center;
		padding: 0.35rem 0.4rem;
		border-radius: 6px;
		background: #101735;
		border: 1px solid #262c54;
	}
	.notification-panel {
		position: fixed;
		right: 1.5rem;
		bottom: 1.5rem;
		width: min(420px, 92vw);
		max-height: 70vh;
		overflow: auto;
		padding: 1rem;
		border-radius: 12px;
		background: #141a2e;
		border: 1px solid #2a2f55;
		box-shadow: 0 20px 40px rgba(0,0,0,0.35);
		z-index: 20;
	}
	.notification-section {
		margin-top: 0.75rem;
	}
	.view { display: none; }
	.view.active { display: block; }
	.footer { margin-top: auto; text-align: center; font-size: 0.8rem; color: #9aa3c4; padding: 1.5rem 0; }
	.admin-layout {
		display: grid;
		grid-template-columns: 240px minmax(0, 1fr);
		gap: 1.5rem;
		align-items: start;
	}
	.admin-sidebar {
		position: sticky;
		top: 96px;
		align-self: start;
		height: calc(100vh - 120px);
		padding: 1.25rem 1rem;
		border-radius: 18px;
		background: var(--panel-strong);
		border: 1px solid var(--border);
		display: flex;
		flex-direction: column;
		gap: 1rem;
	}
	.admin-sidebar .label {
		font-size: 0.75rem;
		letter-spacing: 0.08em;
		text-transform: uppercase;
	}
	.admin-nav {
		display: flex;
		flex-direction: column;
		gap: 0.5rem;
	}
	.admin-nav button {
		text-align: left;
		padding: 0.5rem 0.75rem;
		border-radius: 10px;
		background: transparent;
		border: 1px solid transparent;
		color: #c7cce7;
	}
	.admin-nav button.active,
	.admin-nav button:hover {
		border-color: #3b82f6;
		background: rgba(59, 130, 246, 0.15);
		color: #e0e7ff;
	}
	.admin-topbar {
		display: flex;
		align-items: center;
		justify-content: space-between;
		gap: 1rem;
		padding: 1rem 1.25rem;
		border-radius: 16px;
		background: rgba(12, 16, 34, 0.92);
		border: 1px solid var(--border);
		margin-bottom: 1rem;
	}
	.admin-indicators {
		display: flex;
		gap: 0.75rem;
		flex-wrap: wrap;
	}
	.indicator {
		padding: 0.4rem 0.75rem;
		border-radius: 999px;
		border: 1px solid #2a2f55;
		font-size: 0.75rem;
		background: #11162b;
	}
	.indicator.ok { border-color: rgba(34, 197, 94, 0.6); color: #bbf7d0; }
	.indicator.warn { border-color: rgba(245, 158, 11, 0.6); color: #fde68a; }
	.indicator.danger { border-color: rgba(239, 68, 68, 0.6); color: #fecaca; }
	.admin-section {
		margin-bottom: 1.5rem;
	}
	.admin-section h3 {
		margin: 0 0 0.5rem;
		font-size: 1.1rem;
	}
	.admin-grid {
		display: grid;
		grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
		gap: 0.85rem;
	}
	.admin-metric {
		padding: 0.85rem;
		border-radius: 12px;
		background: rgba(8, 12, 26, 0.7);
		border: 1px solid rgba(42, 47, 85, 0.8);
	}
	.admin-control-strip {
		border-top: 1px solid var(--border);
		margin-top: 0.75rem;
		padding-top: 0.75rem;
	}
	.admin-control-strip .row {
		align-items: flex-start;
	}
	.admin-control-strip button[disabled] {
		opacity: 0.5;
		cursor: not-allowed;
	}
	.admin-empty {
		padding: 0.75rem 0.9rem;
		border-radius: 10px;
		border: 1px dashed #2a2f55;
		color: #9aa3c4;
		font-size: 0.85rem;
	}
	@media (max-width: 720px) {
		main {
			padding: 1.25rem;
		}
		header {
			flex-direction: column;
			align-items: flex-start;
			gap: 0.75rem;
			padding: 1rem 1.25rem;
		}
		.app-actions {
			align-items: flex-start;
		}
		.nav-links a {
			margin-left: 0;
			margin-right: 0.75rem;
		}
		.dashboard-grid {
			grid-template-columns: 1fr;
		}
		.grid {
			grid-template-columns: 1fr;
		}
		.row {
			flex-direction: column;
			align-items: stretch;
		}
		.row input,
		.row textarea,
		.row select,
		.row button,
		.stack input,
		.stack textarea,
		.stack select,
		.stack button {
			width: 100%;
		}
		.notification-viewport {
			right: 0.75rem;
			bottom: 4.25rem;
			width: min(380px, 94vw);
			max-height: 75vh;
		}
		.notice {
			flex-direction: column;
			align-items: flex-start;
		}
		.footer {
			position: static;
		}
		.admin-layout {
			grid-template-columns: 1fr;
		}
		.admin-sidebar {
			position: static;
			height: auto;
		}
	}
	</style>
</head>
<body>
	<header>
		<div class="app-title">
			<div class="app-mark">TC</div>
			<div>
				<h1>Too Many Coins</h1>
				<div class="label">Season command center ¬∑ server-authoritative economy</div>
			</div>
		</div>
		<div class="app-actions">
			<div class="row">
				<span class="badge">ALPHA 1</span>
				<span id="stat-pill" class="badge accent" style="display:none;"></span>
				<span id="live-status" class="live-status">Live updates</span>
			</div>
			<nav class="nav-links">
				<a href="#/home">Home</a>
				<a href="#/about">About</a>
				<a href="#/playtest">Playtest</a>
				<a href="#/leaderboard">Leaderboard</a>
				<a id="signup-link" href="#/signup">Sign up</a>
				<a id="moderator-link" href="#/moderator" style="display:none;">Moderate</a>
				<a id="admin-link" href="#/admin" style="display:none;">Admin</a>
			</nav>
		</div>
	</header>

	<button id="notification-bell" class="notification-bell" type="button" aria-label="Notifications">
		<span class="notification-bell-icon">üîî</span>
		<span id="notification-badge" class="notification-badge" style="display:none;"></span>
	</button>
	<div id="notification-viewport" class="notification-viewport" aria-hidden="true" style="display:none;">
		<div class="row" style="justify-content:space-between; align-items:center;">
			<strong>Notifications</strong>
			<span id="notification-unread-label" class="label muted"></span>
		</div>
		<div id="notification-list" class="notification-list"></div>
		<div id="notification-empty" class="notification-empty" style="display:none;">No notifications yet.</div>
	</div>

	<main id="app">
		<section id="view-home" class="view active">
			<div class="card hero-card">
				<div class="hero-grid">
					<div>
						<div class="label">Season dashboard</div>
						<h2 style="margin:0.35rem 0 0;">Real-time economy & star pricing</h2>
						<div class="muted">Live season time, emission, and price updates from the server.</div>
					</div>
					<div class="metric-grid">
						<div class="metric">
							<div class="label">Current season</div>
							<div id="hero-season-id" class="stat-value">--</div>
						</div>
						<div class="metric">
							<div id="hero-time-label" class="label">Time remaining</div>
							<div id="hero-season-remaining" class="stat-value">--</div>
						</div>
						<div class="metric">
							<div id="hero-star-label" class="label">Star price</div>
							<div id="hero-star-price" class="stat-value">--</div>
						</div>
						<div class="metric">
							<div class="label">Inflation pressure</div>
							<div id="hero-inflation" class="stat-value">--</div>
						</div>
						<div class="metric">
							<div class="label">Market pressure</div>
							<div id="hero-pressure" class="stat-value">--</div>
						</div>
					</div>
				</div>
			</div>
			<div class="card">
				<div class="label">Alpha limitations</div>
				<ul class="muted" style="margin:0.5rem 0 0; padding-left:1.2rem;">
					<li>Trading is disabled.</li>
					<li>Multi‚Äëseason play is disabled (single active season only).</li>
					<li>Cosmetics, collections, and profiles beyond basics are post‚Äëalpha.</li>
				</ul>
			</div>

			<div class="dashboard-grid">
				<div class="dashboard-main">
					<div id="locked-message" class="label"></div>
					<div class="card" id="season-snapshot" style="display:none;">
						<div class="card-header">
							<div>
								<div class="label">Season snapshot</div>
								<div id="season-title" class="stat-value">--</div>
							</div>
							<span id="season-status" class="badge accent">Active</span>
						</div>
						<div class="metric-grid">
							<div class="metric">
								<div id="season-time-label" class="label">Time remaining</div>
								<div id="season-remaining" class="stat-value">--</div>
							</div>
							<div class="metric">
								<div id="season-star-label" class="label">Star price</div>
								<div id="season-star-price" class="stat-value">--</div>
							</div>
							<div class="metric">
								<div class="label">Coins in circulation</div>
								<div id="season-coins" class="stat-value">--</div>
							</div>
							<div class="metric">
								<div class="label">Inflation pressure</div>
								<div id="season-emission" class="stat-value">--</div>
							</div>
							<div class="metric">
								<div class="label">Market pressure</div>
								<div id="season-pressure" class="stat-value">--</div>
							</div>
							<div class="metric">
								<div class="label">Next coin wave</div>
								<div id="season-next-emission" class="stat-value">--</div>
							</div>
						</div>
						<div id="season-scarcity-message" class="label muted" style="margin-top:0.75rem;"></div>
					</div>
					<div id="seasons" class="grid">Loading season‚Ä¶</div>
				</div>

				<div class="dashboard-side">
					<div class="card" id="auth-card">
						<div id="auth-status" class="label">Checking session‚Ä¶</div>
						<div id="auth-forms" class="stack">
							<div class="row">
								<input id="username" placeholder="Username" />
								<input id="password" type="password" placeholder="Password" />
							</div>
							<div class="row">
								<button class="primary" id="login-btn" type="button">Log in</button>
								<a class="muted" href="#/signup">Create account</a>
							</div>
							<div class="row">
								<a class="muted" href="#/reset">Forgot password?</a>
							</div>
							<div class="muted">Alpha accounts are local to this test.</div>
						</div>
						<button id="logout-btn" style="display:none;">Log out</button>
					</div>

					<div id="toast" class="toast" style="display:none;"></div>

					<div class="grid" id="player-panels" style="display:none;">
						<div class="card" id="profile-card">
							<div class="card-toggle">
								<div class="label">User panel</div>
							</div>
							<div class="card-body">
								<div class="row">
									<img id="profile-avatar-img" alt="Avatar" style="width:64px; height:64px; border-radius:12px; object-fit:cover; border:1px solid #2a2f55;" />
									<div>
										<div id="profile-name"></div>
										<div id="profile-role" class="label"></div>
										<div id="profile-coins" class="label"></div>
										<div id="profile-stars" class="label"></div>
									</div>
								</div>
								<input id="profile-display" placeholder="Display name" />
								<input id="profile-pronouns" placeholder="Pronouns" />
								<input id="profile-location" placeholder="Location" />
								<input id="profile-website" placeholder="Website" />
								<input id="profile-avatar" placeholder="Avatar URL" />
								<textarea id="profile-bio" rows="3" placeholder="Bio"></textarea>
								<input id="profile-email" placeholder="Email (for password reset)" />
								<button id="profile-save">Save</button>
								<div class="notification-settings">
									<div class="label">Notification settings</div>
									<div class="muted">Choose what appears in-app and what can send push alerts.</div>
									<div id="notification-settings-list" class="notification-settings-list"></div>
								</div>
							</div>
						</div>
					</div>

					<div class="card" id="onboarding" style="display:none;">
						<div class="label">Quick start</div>
						<div>Play the current season. Earn coins over time. Spend them on stars.</div>
						<button id="dismiss-hint">Got it</button>
					</div>

					<div class="card" id="actions-card" style="display:none;">
						<div class="label">Quick actions</div>
						<div class="row">
							<button id="claim-daily" class="primary">Daily claim</button>
							<button id="claim-activity">Activity claim</button>
						</div>
						<div id="actions-status" class="muted"></div>
					</div>

				</div>
			</div>
		</section>

		<section id="view-about" class="view">
			<div class="section-stack">
				<div class="card hero-card">
					<div class="card-header">
						<div>
							<div class="label">About Too Many Coins</div>
							<h2 style="margin:0.35rem 0 0;">A server-authoritative economy built on scarcity.</h2>
							<div class="muted">Coins inflate, stars stay scarce, and every purchase is priced on the server.</div>
						</div>
						<div class="section-nav">
							<a href="#/home">Back to home</a>
							<a href="#/playtest">Playtest notes</a>
						</div>
					</div>
				</div>

				<div class="split-grid">
					<div class="card">
						<div class="label">Core loop</div>
						<ul class="muted" style="margin:0.5rem 0 0; padding-left:1.2rem;">
							<li>Earn coins through limited faucets.</li>
							<li>Buy stars as the season score.</li>
							<li>Prices rise as time passes and demand grows.</li>
						</ul>
					</div>
					<div class="card">
						<div class="label">Design ideals</div>
						<ul class="muted" style="margin:0.5rem 0 0; padding-left:1.2rem;">
							<li>Simple, transparent, and fair.</li>
							<li>Server authority for all economy logic.</li>
							<li>Late-season scarcity stays meaningful.</li>
						</ul>
					</div>
				</div>
			</div>
		</section>

		<section id="view-playtest" class="view">
			<div class="section-stack">
				<div class="card hero-card">
					<div class="card-header">
						<div>
							<div class="label">Playtest focus</div>
							<h2 style="margin:0.35rem 0 0;">Verify pacing, clarity, and late-season pressure.</h2>
							<div class="muted">Short sessions are fine‚Äîevery data point helps tune the economy.</div>
						</div>
						<div class="section-nav">
							<a href="#/home">Back to home</a>
							<a href="#/about">About</a>
						</div>
					</div>
				</div>
				<div class="split-grid">
					<div class="card">
						<div class="label">What to test</div>
						<ul class="muted" style="margin:0.5rem 0 0; padding-left:1.2rem;">
							<li>Clarity of the core loop.</li>
							<li>Faucet pacing vs. star price growth.</li>
							<li>Perceived late-season scarcity.</li>
						</ul>
					</div>
					<div class="card">
						<div class="label">Suggested cadence</div>
						<div class="muted" style="margin-top:0.5rem;">Play 10‚Äì20 minutes per day and leave feedback in-app.</div>
					</div>
				</div>
			</div>
		</section>

		<section id="view-leaderboard" class="view">
			<div class="section-stack">
				<div class="card hero-card">
					<div class="card-header">
						<div>
							<div class="label">Leaderboard</div>
							<h2 style="margin:0.35rem 0 0;">Season rankings with bots labeled.</h2>
							<div class="muted">Server-authoritative ordering with stable tiebreakers.</div>
						</div>
						<div class="section-nav">
							<a href="#/home">Back to home</a>
						</div>
					</div>
				</div>

				<div class="card">
					<div class="row" style="margin-top:0.5rem;">
						<input id="leaderboard-search" placeholder="Search username or display name" />
						<select id="leaderboard-sort">
							<option value="stars_desc">Stars (high ‚Üí low)</option>
							<option value="stars_asc">Stars (low ‚Üí high)</option>
							<option value="coins_spent_desc">Coins spent (high ‚Üí low)</option>
							<option value="coins_spent_asc">Coins spent (low ‚Üí high)</option>
							<option value="last_star_time_asc">Last star time (earlier first)</option>
							<option value="created_at_asc">Created at (oldest first)</option>
						</select>
						<select id="leaderboard-page-size">
							<option value="25">25 / page</option>
							<option value="50" selected>50 / page</option>
							<option value="100">100 / page</option>
						</select>
					</div>
					<div class="row" style="margin-top:0.5rem;">
						<label class="label"><input type="checkbox" id="leaderboard-include-bots" checked /> Include bots</label>
						<label class="label"><input type="checkbox" id="leaderboard-bot-only" /> Bot-only</label>
						<button id="leaderboard-apply" class="primary">Apply</button>
					</div>
				</div>

				<div id="leaderboard-results" class="stack"></div>
				<div class="row" style="justify-content:space-between; margin-top:0.5rem;">
					<button id="leaderboard-prev">Previous</button>
					<span id="leaderboard-page" class="label"></span>
					<button id="leaderboard-next">Next</button>
				</div>
			</div>
		</section>

		<section id="view-signup" class="view">
			<div class="section-stack" style="max-width: 560px;">
				<div class="card hero-card">
					<div class="label">Create account</div>
					<h2 style="margin:0.35rem 0 0;">Join the season in minutes.</h2>
					<div class="muted">All economy logic is enforced server-side.</div>
				</div>
				<div class="card">
					<div class="stack">
						<input id="signup-username" placeholder="Username" />
						<input id="signup-display-name" placeholder="Display name" />
						<input id="signup-email" placeholder="Email" />
						<input id="signup-password" type="password" placeholder="Password" />
						<button class="primary" id="signup-btn">Sign up</button>
						<div class="label"><a href="#/home">Back to login</a></div>
						<div id="signup-toast" class="toast" style="display:none;"></div>
					</div>
				</div>
			</div>
		</section>

		<section id="view-reset" class="view">
			<div class="section-stack" style="max-width: 560px;">
				<div class="card hero-card">
					<div class="label">Account recovery</div>
					<h2 style="margin:0.35rem 0 0;">Reset access securely.</h2>
					<div class="muted">Reset tokens are validated on the server.</div>
				</div>
				<div class="card">
					<div class="stack">
						<div class="label">Request reset link</div>
						<input id="reset-identifier" placeholder="Email or username" />
						<button class="primary" id="reset-request-btn">Send reset email</button>
						<div id="reset-request-status" class="label"></div>
						<hr style="border:0; border-top:1px solid #2a2f55; width:100%;" />
						<div class="label">Have a token?</div>
						<input id="reset-token" placeholder="Reset token" />
						<input id="reset-new-password" type="password" placeholder="New password" />
						<button class="primary" id="reset-confirm-btn">Reset password</button>
						<div id="reset-confirm-status" class="label"></div>
						<div class="label"><a href="#/home">Back to login</a></div>
					</div>
				</div>
			</div>
		</section>

		<section id="view-admin-initialize" class="view">
			<div class="section-stack" style="max-width: 560px;">
				<div class="card hero-card">
					<div class="label">Admin initialization</div>
					<h2 style="margin:0.35rem 0 0;">Claim the admin account.</h2>
					<div class="muted">Owner-only. Uses the rotating claim code.</div>
				</div>
				<div class="card" id="admin-init-card">
					<div class="stack">
						<input id="admin-claim-code" placeholder="Owner claim code" />
						<input id="admin-claim-password" type="password" placeholder="New admin password" />
						<input id="admin-claim-confirm" type="password" placeholder="Confirm password" />
						<button class="primary" id="admin-claim-submit" type="button">Set admin password</button>
						<div id="admin-claim-status" class="label"></div>
						<div id="admin-claim-rotation" class="muted"></div>
						<div class="label"><a href="#/home">Back to login</a></div>
					</div>
				</div>
			</div>
		</section>

		<section id="view-admin" class="view">
			<div class="section-stack">
				<div class="card hero-card">
					<div class="card-header">
						<div>
							<div class="label">Admin control panel</div>
							<h2 style="margin:0.35rem 0 0;">System integrity, risk, and accountability.</h2>
							<div class="muted">Admins observe, constrain, and intervene. No rewards. No shortcuts.</div>
						</div>
						<div class="section-nav">
							<a href="#/home">Back to game</a>
						</div>
					</div>
				</div>

				<div id="admin-access-denied" class="card" style="display:none;">
					<div class="label">Not authorized</div>
					<div class="label">Admin access is required to view this panel.</div>
				</div>

				<div id="admin-shell" class="admin-layout" style="display:none;">
					<aside class="admin-sidebar">
						<div>
							<div class="label">Admin navigation</div>
							<div class="muted">Risk-first hierarchy. No shortcuts.</div>
						</div>
						<nav class="admin-nav" id="admin-nav">
							<button type="button" data-target="admin-overview">Overview</button>
							<button type="button" data-target="admin-seasons">Seasons</button>
							<button type="button" data-target="admin-anti-cheat">Anti-Cheat</button>
							<button type="button" data-target="admin-players">Players</button>
							<button type="button" data-target="admin-abuse-monitor">Abuse Monitor</button>
							<button type="button" data-target="admin-whitelist">Whitelist</button>
							<button type="button" data-target="admin-bug-reports">Bug Reports</button>
							<button type="button" data-target="admin-emergency">Emergency</button>
							<button type="button" data-target="admin-audit">Audit Log</button>
						</nav>
						<div class="muted" style="margin-top:auto;">Admins do not play the game.</div>
					</aside>

					<div>
						<div class="admin-topbar">
							<div>
								<div class="label">Global indicators</div>
								<div class="muted">Read-only system state</div>
							</div>
							<div class="admin-indicators">
								<div id="admin-indicator-server" class="indicator">Server Status: Loading</div>
								<div id="admin-indicator-economy" class="indicator">Economy State: Loading</div>
								<div id="admin-indicator-abuse" class="indicator">Abuse Signals: Loading</div>
							</div>
						</div>

						<section id="admin-overview" class="admin-section">
							<h3>System Health</h3>
							<div class="card">
								<div class="label">Overview dashboard (read-only)</div>
								<div class="admin-grid" style="margin-top:0.75rem;">
									<div class="admin-metric">
										<div class="label">Active seasons</div>
										<div id="admin-overview-seasons" class="stat-value">--</div>
									</div>
									<div class="admin-metric">
										<div class="label">Coins emitted (last hour)</div>
										<div id="admin-overview-coins" class="stat-value">--</div>
									</div>
									<div class="admin-metric">
										<div class="label">Stars purchased (last hour)</div>
										<div id="admin-overview-stars" class="stat-value">--</div>
									</div>
									<div class="admin-metric">
										<div class="label">Market pressure trend</div>
										<div id="admin-overview-pressure" class="stat-value">--</div>
									</div>
									<div class="admin-metric">
										<div class="label">Active throttles</div>
										<div id="admin-overview-throttles" class="stat-value">--</div>
									</div>
									<div class="admin-metric">
										<div class="label">Active abuse flags</div>
										<div id="admin-overview-flags" class="stat-value">--</div>
									</div>
								</div>
								<div class="row" style="margin-top:0.85rem;">
									<label class="label"><input id="admin-debug-toggle" type="checkbox" /> Show debug banner</label>
									<span class="muted">Local only. For diagnostics.</span>
								</div>
								<div class="muted" style="margin-top:0.75rem;">Live indicators are sourced from server streams. No client-side authority.</div>
							</div>
						</section>

						<section id="admin-seasons" class="admin-section">
							<h3>Season Integrity</h3>
							<div class="card">
								<div class="label">Seasons (system state)</div>
								<div id="admin-season-list" class="section-stack" style="margin-top:0.75rem;"></div>
								<div class="admin-empty" id="admin-season-empty" style="display:none;">No season data available.</div>
							</div>
							<div class="card" id="admin-season-status" style="display:none;">
								<div class="label">SEASON STATUS</div>
								<div class="admin-grid" style="margin-top:0.75rem;">
									<div class="admin-metric"><div class="label">Phase</div><div class="stat-value">ALPHA</div></div>
									<div class="admin-metric"><div class="label">Season</div><div class="stat-value" id="admin-season-status-id">--</div></div>
									<div class="admin-metric"><div class="label">Status</div><div class="stat-value" id="admin-season-status-value">--</div></div>
									<div class="admin-metric"><div class="label">Day</div><div class="stat-value" id="admin-season-status-day">--</div></div>
									<div class="admin-metric"><div class="label">Ends</div><div class="stat-value" id="admin-season-status-ends">--</div></div>
									<div class="admin-metric"><div class="label">Rollover</div><div class="stat-value">Automatic on natural end</div></div>
								</div>
								<div class="muted" id="admin-season-status-message" style="margin-top:0.75rem;"></div>
							</div>
							<div class="card" id="admin-season-detail" data-collapsible="true" style="display:none;">
								<div class="card-toggle">
									<div class="label">Season detail</div>
									<button class="toggle-btn" type="button">Hide</button>
								</div>
								<div class="card-body">
									<div id="admin-season-metrics" class="admin-grid"></div>
									<div class="admin-control-strip" data-admin-controls style="display:none;">
										<div class="label">Control strip (guarded)</div>
										<div class="muted">Actions explain impact. All changes are server-enforced and audited.</div>
										<div class="row" style="margin-top:0.75rem;">
											<button type="button" disabled>Pause star purchases</button>
											<div class="muted">Prevents new star buys to stop price acceleration.</div>
										</div>
										<div class="row">
											<button type="button" disabled>Reduce emission rate</button>
											<div class="muted">Reduces daily emission target to slow inflation.</div>
										</div>
										<div class="row">
											<button type="button" disabled>Disable trading</button>
											<div class="muted">Suspends trading to halt exploit loops.</div>
										</div>
										<div class="row">
											<button type="button" class="danger" disabled>Freeze season</button>
											<div class="muted">Freezes all season activity. Requires double-confirmation.</div>
										</div>
									</div>
								</div>
							</div>
						</section>

						<section id="admin-anti-cheat" class="admin-section">
							<h3>Anti-Cheat &amp; Abuse Controls</h3>
							<div class="card">
								<div class="label">Global toggles</div>
								<div class="admin-grid" style="margin-top:0.75rem;">
									<div class="admin-metric">Enable IP enforcement ¬∑ <span id="admin-toggle-ip">--</span></div>
									<div class="admin-metric">Enable clustering detection ¬∑ <span id="admin-toggle-cluster">--</span></div>
									<div class="admin-metric">Enable automatic throttling ¬∑ <span id="admin-toggle-throttle">--</span></div>
									<div class="admin-metric">Enable trade tightening ¬∑ <span id="admin-toggle-trade">--</span></div>
									<div class="admin-metric">Enable bot heuristics ¬∑ <span id="admin-toggle-bots">--</span></div>
								</div>
								<div class="muted" style="margin-top:0.75rem;">Toggles are server-enforced only. No client authority.</div>
							</div>
							<div class="card">
								<div class="label">Sensitivity controls</div>
								<div class="admin-grid" style="margin-top:0.75rem;">
									<div class="admin-metric">Clustering sensitivity: <span id="admin-sense-cluster">--</span></div>
									<div class="admin-metric">Throttle ramp speed: <span id="admin-sense-throttle">--</span></div>
									<div class="admin-metric">Trade tightening curve: <span id="admin-sense-trade">--</span></div>
									<div class="admin-metric">Faucet response: <span id="admin-sense-faucet">--</span></div>
								</div>
								<div class="muted" style="margin-top:0.75rem;">Sensitivity shapes system behavior, not individual outcomes.</div>
							</div>
							<div class="card">
								<div class="label">Visibility-only signals</div>
								<div id="admin-abuse-stream" class="admin-empty" style="margin-top:0.75rem;">Streaming abuse events will appear here.</div>
								<div class="admin-grid" style="margin-top:0.75rem;">
									<div class="admin-metric">Severity distribution: <span id="admin-abuse-severity">--</span></div>
									<div class="admin-metric">IP-group concentration: <span id="admin-abuse-heatmap">--</span></div>
								</div>
							</div>
						</section>

						<section id="admin-players" class="admin-section">
							<h3>Player &amp; Network Oversight</h3>
							<div class="card">
								<div class="label">Player search (precision, not power)</div>
								<div class="row" style="margin-top:0.75rem;">
									<input id="admin-player-query" placeholder="Username, Player ID, Account ID" />
									<select id="admin-player-trust">
										<option value="">Trust status</option>
										<option value="normal">Normal</option>
										<option value="throttled">Throttled</option>
										<option value="flagged">Flagged</option>
									</select>
									<button id="admin-player-search" class="primary" type="button" disabled>Search</button>
								</div>
								<div id="admin-player-results" class="section-stack" style="margin-top:0.75rem;"></div>
								<div class="admin-empty" id="admin-player-empty">Search results will appear here.</div>
							</div>
						</section>

						<section id="admin-abuse-monitor" class="admin-section">
							<h3>Abuse Monitor</h3>
							<div class="card">
								<div class="label">Pattern-first signals</div>
								<div id="admin-abuse-patterns" class="admin-empty" style="margin-top:0.75rem;">Clusters, trade loops, and anomalies will surface here.</div>
							</div>
						</section>

						<section id="admin-whitelist" class="admin-section">
							<h3>Whitelist Management</h3>
							<div class="card">
								<div class="label">Batch review only</div>
								<div class="muted">Requests grouped by IP hash. Approvals happen in waves.</div>
								<div id="admin-whitelist-queue" class="admin-empty" style="margin-top:0.75rem;">Whitelist queue is offline.</div>
							</div>
						</section>

						<section id="admin-bug-reports" class="admin-section">
							<h3>Bug Reports (Read-Only)</h3>
							<div class="card">
								<div class="label">Player-submitted bug reports</div>
								<div class="muted">Reports are immutable and for observation only. No responses or feedback loop in Alpha.</div>
								<div class="row" style="margin-top:0.75rem;">
									<input id="admin-bug-search" placeholder="Search by title or description" />
									<button id="admin-bug-refresh" class="primary" type="button">Refresh</button>
								</div>
								<div id="admin-bug-results" class="section-stack" style="margin-top:0.75rem;"></div>
								<div class="admin-empty" id="admin-bug-empty">No bug reports yet.</div>
							</div>
						</section>

						<section id="admin-emergency" class="admin-section">
							<h3>EMERGENCY OVERRIDES (ALPHA)</h3>
							<div class="card">
								<div class="label">Acknowledgement required</div>
								<div class="muted">‚ÄúI understand this affects all players.‚Äù</div>
								<div class="admin-control-strip" style="margin-top:0.75rem; display:none;" data-admin-controls>
									<div class="row">
										<button type="button" class="danger" disabled>Pause all purchases</button>
										<div class="muted">Stops all star and boost purchases across seasons.</div>
									</div>
									<div class="row">
										<button type="button" class="danger" disabled>Pause all emission</button>
										<div class="muted">Halts emission for all faucets and drips.</div>
									</div>
									<div class="row">
										<button type="button" class="danger" disabled>Freeze all seasons</button>
										<div class="muted">Freezes every season immediately. Requires double-confirmation.</div>
									</div>
								</div>
							</div>
						</section>

						<section id="admin-audit" class="admin-section">
							<h3>Audit &amp; History</h3>
							<div class="card">
								<div class="label">Immutable audit log</div>
								<div class="row" style="margin-top:0.75rem;">
									<input id="admin-audit-search" placeholder="Search by actor, action, scope" />
									<button id="admin-audit-run" type="button" disabled>Search</button>
								</div>
								<div id="admin-audit-results" class="section-stack" style="margin-top:0.75rem;"></div>
								<div class="admin-empty" id="admin-audit-empty">Audit entries will appear here.</div>
							</div>
						</section>
					</div>
				</div>
			</div>
		</section>

		<section id="view-moderator" class="view">
			<div class="section-stack">
				<div class="card hero-card">
					<div class="card-header">
						<div>
							<div class="label">Profile moderation</div>
							<h2 style="margin:0.35rem 0 0;">View and edit profiles with server authority.</h2>
							<div class="muted">Moderators edit user profiles. Admins can freeze or delete accounts.</div>
						</div>
						<div class="section-nav">
							<a href="#/home">Back to game</a>
						</div>
					</div>
				</div>

				<div class="card" id="moderator-content" data-collapsible="true" style="display:none;">
					<div class="card-toggle">
						<div class="label">Find profile</div>
						<button class="toggle-btn" type="button">Hide</button>
					</div>
					<div class="card-body">
						<div class="row" style="margin-top:0.5rem;">
							<input id="mod-username-view" placeholder="Username" />
							<button id="mod-load-view" class="primary">Load</button>
						</div>
						<div id="mod-status-view" class="label"></div>
					</div>
				</div>

				<div class="card" id="moderator-profile" data-collapsible="true" style="display:none;">
					<div class="card-toggle">
						<div class="label">Profile details</div>
						<button class="toggle-btn" type="button">Hide</button>
					</div>
					<div class="card-body">
						<div class="row" style="margin-top:0.5rem;">
							<input id="mod-display-name-view" placeholder="Display name" />
							<button id="mod-save-view" class="primary">Update</button>
						</div>
						<div class="row" style="margin-top:0.5rem;">
							<input id="mod-email-view" placeholder="Email" />
							<input id="mod-pronouns-view" placeholder="Pronouns" />
							<input id="mod-location-view" placeholder="Location" />
						</div>
						<div class="row" style="margin-top:0.5rem;">
							<input id="mod-website-view" placeholder="Website" />
							<input id="mod-avatar-view" placeholder="Avatar URL" />
						</div>
						<textarea id="mod-bio-view" rows="3" placeholder="Bio"></textarea>
					</div>
				</div>

				<div class="card" id="mod-no-access" style="display:none;">
					<div class="label">Not authorized</div>
					<div class="label">You need a moderator or admin account to view this page.</div>
				</div>
			</div>

			<div class="card collapsed" id="mod-admin-actions" data-collapsible="true" style="display:none;">
				<div class="card-toggle">
					<div class="label">Admin actions</div>
					<button class="toggle-btn" type="button">Show</button>
				</div>
				<div class="card-body">
					<div class="muted">Admin-only. Actions apply to the loaded profile.</div>
					<div class="row" style="margin-top:0.5rem;">
						<button id="mod-freeze" class="danger">Freeze account</button>
						<button id="mod-unfreeze">Unfreeze account</button>
						<button id="mod-delete" class="danger">Delete account</button>
					</div>
					<div id="mod-admin-status" class="label"></div>
				</div>
			</div>
		</section>
		<section id="view-bug-report" class="view" style="display:none;">
			<div class="section-stack" style="max-width: 560px;">
				<div class="card hero-card">
					<div class="label">Report a bug</div>
					<h2 style="margin:0.35rem 0 0;">Help us improve Too Many Coins.</h2>
					<div class="muted">Bug reports are read-only during Alpha. You won't receive replies.</div>
				</div>
				<div class="card">
					<div class="stack">
						<input id="bug-title" placeholder="Brief bug title" maxlength="200" />
						<textarea id="bug-description" rows="6" placeholder="Describe the issue in detail. What were you doing? What happened?"></textarea>
						<select id="bug-category">
							<option value="other">Category: Other</option>
							<option value="ui">Category: UI / Display</option>
							<option value="economy">Category: Economy / Coins</option>
							<option value="performance">Category: Performance / Speed</option>
						</select>
						<input id="bug-client-version" placeholder="Client version (optional)" maxlength="50" />
						<button class="primary" id="bug-submit">Submit report</button>
						<div id="bug-status" class="label"></div>
						<button id="bug-cancel">Back</button>
					</div>
				</div>
			</div>
		</section>
	</main>

	<div class="footer">
		Made by AI ¬∑ <a href="#" id="report-bug-link" style="color:#c5cae9; text-decoration:none; cursor:pointer;">Report a bug</a>
	</div>
	<div id="debug-status" class="toast" style="display:none; position:fixed; left:1rem; bottom:1rem; z-index:40; max-width:420px;"></div>
	<script>
		(() => {
			const query = location.search || "";
			const show = query.includes("debug=1") || location.hash.includes("debug=1");
			if (!show) return;
			const el = document.getElementById("debug-status");
			if (!el) return;
			el.style.display = "block";
			el.className = "toast";
			el.innerText = "Inline JS OK. Waiting for app boot...";
			window.__INLINE_DEBUG__ = true;
			window.addEventListener("error", (event) => {
				const msg = event && event.message ? event.message : "Unknown error";
				el.innerText = `Inline error: ${msg}`;
			});
			window.addEventListener("unhandledrejection", () => {
				el.innerText = "Inline error: unhandled rejection";
			});
		})();
	</script>

	<script>
const authStatus = document.getElementById("auth-status");
const authForms = document.getElementById("auth-forms");
const logoutBtn = document.getElementById("logout-btn");
const profileName = document.getElementById("profile-name");
const profileRole = document.getElementById("profile-role");
const profileDisplay = document.getElementById("profile-display");
const profileEmail = document.getElementById("profile-email");
const profilePronouns = document.getElementById("profile-pronouns");
const profileLocation = document.getElementById("profile-location");
const profileWebsite = document.getElementById("profile-website");
const profileAvatar = document.getElementById("profile-avatar");
const profileAvatarImg = document.getElementById("profile-avatar-img");
const profileBio = document.getElementById("profile-bio");
const seasonSnapshot = document.getElementById("season-snapshot");
const profileSave = document.getElementById("profile-save");
const playerPanels = document.getElementById("player-panels");
const coinsDiv = document.getElementById("profile-coins");
const starsDiv = document.getElementById("profile-stars");
const onboarding = document.getElementById("onboarding");
const actionsCard = document.getElementById("actions-card");
const actionsStatus = document.getElementById("actions-status");
const toast = document.getElementById("toast");
const statPill = document.getElementById("stat-pill");
const notificationBell = document.getElementById("notification-bell");
const notificationBadge = document.getElementById("notification-badge");
const notificationViewport = document.getElementById("notification-viewport");
const notificationList = document.getElementById("notification-list");
const notificationEmpty = document.getElementById("notification-empty");
const notificationUnreadLabel = document.getElementById("notification-unread-label");
const notificationSettingsList = document.getElementById("notification-settings-list");
const signupLink = document.getElementById("signup-link");
const moderatorLink = document.getElementById("moderator-link");
const adminLink = document.getElementById("admin-link");
const liveStatus = document.getElementById("live-status");
const seasonRemaining = document.getElementById("season-remaining");
const seasonStarPrice = document.getElementById("season-star-price");
const seasonCoins = document.getElementById("season-coins");
const seasonEmission = document.getElementById("season-emission");
const seasonPressure = document.getElementById("season-pressure");
const seasonNextEmission = document.getElementById("season-next-emission");
const seasonScarcityMessage = document.getElementById("season-scarcity-message");
const seasonTitle = document.getElementById("season-title");
const seasonStatus = document.getElementById("season-status");
const heroSeasonId = document.getElementById("hero-season-id");
const heroSeasonRemaining = document.getElementById("hero-season-remaining");
const heroStarPrice = document.getElementById("hero-star-price");
const heroInflation = document.getElementById("hero-inflation");
const heroPressure = document.getElementById("hero-pressure");
const leaderboardResults = document.getElementById("leaderboard-results");
const leaderboardPageLabel = document.getElementById("leaderboard-page");
const adminIndicatorServer = document.getElementById("admin-indicator-server");
const adminIndicatorEconomy = document.getElementById("admin-indicator-economy");
const adminIndicatorAbuse = document.getElementById("admin-indicator-abuse");
const adminOverviewSeasons = document.getElementById("admin-overview-seasons");
const adminOverviewCoins = document.getElementById("admin-overview-coins");
const adminOverviewStars = document.getElementById("admin-overview-stars");
const adminOverviewPressure = document.getElementById("admin-overview-pressure");
const adminOverviewThrottles = document.getElementById("admin-overview-throttles");
const adminOverviewFlags = document.getElementById("admin-overview-flags");
const adminSeasonList = document.getElementById("admin-season-list");
const adminSeasonEmpty = document.getElementById("admin-season-empty");
const adminSeasonStatus = document.getElementById("admin-season-status");
const adminSeasonStatusId = document.getElementById("admin-season-status-id");
const adminSeasonStatusValue = document.getElementById("admin-season-status-value");
const adminSeasonStatusDay = document.getElementById("admin-season-status-day");
const adminSeasonStatusEnds = document.getElementById("admin-season-status-ends");
const adminSeasonStatusMessage = document.getElementById("admin-season-status-message");
const adminSeasonDetail = document.getElementById("admin-season-detail");
const adminSeasonMetrics = document.getElementById("admin-season-metrics");
const debugStatus = document.getElementById("debug-status");
const adminDebugToggle = document.getElementById("admin-debug-toggle");
const adminClaimCode = document.getElementById("admin-claim-code");
const adminClaimPassword = document.getElementById("admin-claim-password");
const adminClaimConfirm = document.getElementById("admin-claim-confirm");
const adminClaimSubmit = document.getElementById("admin-claim-submit");
const adminClaimStatus = document.getElementById("admin-claim-status");
const adminClaimRotation = document.getElementById("admin-claim-rotation");
const adminInitCard = document.getElementById("admin-init-card");

if (window.__INLINE_DEBUG__ && debugStatus) {
	debugStatus.innerText = "App script running.";
}
const adminToggleIP = document.getElementById("admin-toggle-ip");
const adminToggleCluster = document.getElementById("admin-toggle-cluster");
const adminToggleThrottle = document.getElementById("admin-toggle-throttle");
const adminToggleTrade = document.getElementById("admin-toggle-trade");
const adminToggleBots = document.getElementById("admin-toggle-bots");
const adminSenseCluster = document.getElementById("admin-sense-cluster");
const adminSenseThrottle = document.getElementById("admin-sense-throttle");
const adminSenseTrade = document.getElementById("admin-sense-trade");
const adminSenseFaucet = document.getElementById("admin-sense-faucet");
const adminAbuseHeatmap = document.getElementById("admin-abuse-heatmap");

const views = Array.from(document.querySelectorAll(".view"));
const viewMap = {
	home: "view-home",
	about: "view-about",
	playtest: "view-playtest",
	leaderboard: "view-leaderboard",
	signup: "view-signup",
	reset: "view-reset",
	"admin/initialize": "view-admin-initialize",
	admin: "view-admin",
	moderator: "view-moderator"
};

let playerCoins = 0;
let playerStars = 0;
let currentUser = null;
let homeInitialized = false;
let moderatorInitialized = false;
let adminInitialized = false;
let signupInitialized = false;
let resetInitialized = false;
let adminBootstrapInitialized = false;
let leaderboardInitialized = false;
let playerRefreshInterval = null;
let seasonRefreshInterval = null;
let activityPingInterval = null;
let liveEventSource = null;
let notificationEventSource = null;
let lastNotificationId = 0;
const bulkStarMax = 5;
let leaderboardPage = 1;
const notificationCategories = [
	"economy",
	"player_action",
	"market",
	"abuse",
	"system",
	"admin"
];
let notificationSettings = {};
let notificationSettingsSaveTimer = null;
let notificationPanelOpen = false;
let notificationsCache = [];
let adminOverviewTimer = null;
let adminAbuseTimer = null;
let adminAntiCheatTimer = null;
let currentSeasonSnapshot = null;

// Bootstrap gate state
let bootstrapSeasonReady = false;
let bootstrapGateResolved = false;
let bootstrapTimeoutId = null;

function apiFetch(url, options = {}) {
	return fetch(url, {
		...options,
		headers: {
			"Content-Type": "application/json",
			...(options.headers || {})
		},
		credentials: "include"
	});
}

function isDebugEnabled() {
	const query = location.search || "";
	if (query.includes("debug=1") || location.hash.includes("debug=1")) {
		return true;
	}
	return localStorage.getItem("tmc_debug_banner") === "true";
}

function updateDebugVisibility() {
	if (!debugStatus) return;
	debugStatus.style.display = isDebugEnabled() ? "block" : "none";
}

function setDebugStatus(message) {
	if (!debugStatus || !isDebugEnabled()) return;
	debugStatus.style.display = "block";
	debugStatus.className = "toast";
	debugStatus.innerText = message;
}

async function apiFetchJson(url, options = {}, timeoutMs = 3000) {
	const controller = new AbortController();
	const timer = setTimeout(() => controller.abort(), timeoutMs);
	try {
		const res = await apiFetch(url, { ...options, signal: controller.signal });
		const data = await res.json();
		return { res, data };
	} catch (e) {
		return { res: null, data: null };
	} finally {
		clearTimeout(timer);
	}
}

async function track(eventType, payload) {
	try {
		await apiFetch("/telemetry", {
			method: "POST",
			body: JSON.stringify({ eventType, payload })
		});
	} catch (e) {}
}

function formatRemaining(seconds) {
	if (seconds <= 0) return "Season ended";
	const days = Math.floor(seconds / 86400);
	const hours = Math.floor((seconds % 86400) / 3600);
	const minutes = Math.floor((seconds % 3600) / 60);
	if (days > 0) return `${days}d ${hours}h`;
	if (hours > 0) return `${hours}h ${minutes}m`;
	return `${minutes}m`;
}

function formatPressure(value) {
	if (typeof value !== "number" || !isFinite(value)) return "--";
	return `${value.toFixed(2)}x`;
}

function seasonStatusValue(season) {
	if (!season) return "active";
	if (typeof season.status === "string" && season.status) {
		return season.status;
	}
	if (typeof season.season_status === "string" && season.season_status) {
		return season.season_status;
	}
	return season.secondsRemaining > 0 ? "active" : "ended";
}

function seasonStatusLabel(season) {
	return seasonStatusValue(season) === "ended" ? "Ended" : "Active";
}

function formatEmissionValue(value, ended) {
	if (ended) return "Frozen";
	if (typeof value !== "number" || !isFinite(value)) return "--";
	return `${value.toFixed(2)} / min`;
}

function formatPressureValue(value, ended) {
	if (ended) return "Frozen";
	return formatPressure(value);
}

function formatNextEmissionValue(value, ended) {
	if (ended) return "Ended";
	if (typeof value !== "number" || !isFinite(value)) return "--";
	return `${value}s`;
}

// Canonical formatters: convert server microcoins to display coins
// Server always returns microcoins (1 coin = 1000 microcoins)
// These formatters ensure consistent display across all UI contexts
function formatMicrocoinsToCoins(microcoins) {
	if (typeof microcoins !== "number" || !isFinite(microcoins)) {
		return null;
	}
	return (microcoins / 1000).toFixed(3);
}

function formatMicrocoinsToCoinsDisplay(microcoins) {
	const formatted = formatMicrocoinsToCoins(microcoins);
	return formatted !== null ? `${formatted} coins` : "--";
}

function formatCoinsInCirculationForSeason(season) {
	const ended = seasonStatusValue(season) === "ended";
	const rawCoins = ended && typeof season?.finalCoinsInCirculation === "number"
		? season.finalCoinsInCirculation
		: season?.coinsInCirculation;
	const count = formatMicrocoinsToCoins(rawCoins);
	if (ended) {
		return count === null ? "Final snapshot recorded" : `Final snapshot: ${count} coins`;
	}
	return count === null ? "--" : `${count} coins`;
}

function scarcityMessage(secondsRemaining) {
	if (typeof secondsRemaining !== "number" || secondsRemaining <= 0) {
		return "";
	}
	const daysRemaining = secondsRemaining / 86400;
	if (daysRemaining <= 3) {
		return "Late-season scarcity is peaking. Prices spike faster now.";
	}
	if (daysRemaining <= 7) {
		return "Late-season scarcity is rising. Prices will climb faster.";
	}
	return "";
}

function updateLiveStatus(state, message) {
	if (!liveStatus) return;
	liveStatus.classList.remove("offline", "reconnecting");
	if (state === "offline") {
		liveStatus.classList.add("offline");
		liveStatus.innerText = message || "Offline";
		return;
	}
	if (state === "reconnecting") {
		liveStatus.classList.add("reconnecting");
		liveStatus.innerText = message || "Reconnecting";
		return;
	}
	liveStatus.innerText = message || "Live updates";
}

function formatSeasonDisplayNumber(season) {
	// Derive player-facing season number from server data
	// Internal season IDs must NEVER be exposed to players
	if (!season) return "Season 0";
	
	// If server provides an explicit season_number field, use it
	if (typeof season.season_number === "number") {
		return `Season ${season.season_number}`;
	}
	
	// Alpha constraint: single active season only, defaults to Season 0
	// (Future: if multi-season exists, server will provide season_number)
	if (isDebugEnabled()) {
		console.warn("Season object missing season_number field; defaulting to Season 0");
	}
	return "Season 0";
}

function updateSeasonSnapshot(season) {
	if (!season) return;
	currentSeasonSnapshot = season;
	
	// SSE OVERLAY PATTERN: Update DOM elements with server snapshot values.
	// Do NOT re-render the season card here; that's done once by loadSeasons.
	// This function overlays live/updated values on top of the existing structure.
	
	const ended = seasonStatusValue(season) === "ended";
	const starPriceValue = ended && typeof season.finalStarPrice === "number"
		? season.finalStarPrice
		: season.currentStarPrice;
	const coinsValue = ended && typeof season.finalCoinsInCirculation === "number"
		? season.finalCoinsInCirculation
		: season.coinsInCirculation;
	
	// Update season snapshot panel (if visible)
	if (seasonTitle) seasonTitle.innerText = formatSeasonDisplayNumber(season);
	if (seasonRemaining) seasonRemaining.innerText = ended ? "Season ended ‚Äî read-only." : formatRemaining(season.secondsRemaining || 0);
	if (seasonStarPrice) seasonStarPrice.innerText = formatMicrocoinsToCoinsDisplay(starPriceValue);
	if (seasonCoins) seasonCoins.innerText = formatCoinsInCirculationForSeason({ ...season, coinsInCirculation: coinsValue });
	if (seasonEmission) seasonEmission.innerText = formatEmissionValue(season.coinEmissionPerMinute, ended);
	if (seasonPressure) seasonPressure.innerText = formatPressureValue(season.marketPressure, ended);
	if (seasonNextEmission) seasonNextEmission.innerText = formatNextEmissionValue(season.nextEmissionInSeconds, ended);
	if (seasonScarcityMessage) seasonScarcityMessage.innerText = scarcityMessage(season.secondsRemaining || 0);
	
	// Update hero panel (top dashboard)
	if (heroSeasonId) heroSeasonId.innerText = formatSeasonDisplayNumber(season);
	if (heroSeasonRemaining) heroSeasonRemaining.innerText = ended ? "Season ended ‚Äî read-only." : formatRemaining(season.secondsRemaining || 0);
	if (heroStarPrice) heroStarPrice.innerText = formatMicrocoinsToCoinsDisplay(starPriceValue);
	if (heroInflation) heroInflation.innerText = formatEmissionValue(season.coinEmissionPerMinute, ended);
	if (heroPressure) heroPressure.innerText = formatPressureValue(season.marketPressure, ended);
	if (seasonStatus) {
		seasonStatus.innerText = seasonStatusLabel(season);
	}
	const heroTimeLabel = document.getElementById("hero-time-label");
	const heroStarLabel = document.getElementById("hero-star-label");
	const seasonTimeLabel = document.getElementById("season-time-label");
	const seasonStarLabel = document.getElementById("season-star-label");
	if (heroTimeLabel) heroTimeLabel.innerText = ended ? "Season status" : "Time remaining";
	if (seasonTimeLabel) seasonTimeLabel.innerText = ended ? "Season status" : "Time remaining";
	if (heroStarLabel) heroStarLabel.innerText = ended ? "Final star price snapshot" : "Star price";
	if (seasonStarLabel) seasonStarLabel.innerText = ended ? "Final star price snapshot" : "Star price";
	updateSeasonActionsState(season);
	updateAdminControlVisibility(season);
}

function updateSeasonCard(season) {
	if (!season) return;
	const card = document.querySelector(`[data-season-id="${season.seasonId}"]`);
	if (!card) return;
	const ended = seasonStatusValue(season) === "ended";
	const starPriceValue = ended && typeof season.finalStarPrice === "number"
		? season.finalStarPrice
		: season.currentStarPrice;
	const coinsValue = ended && typeof season.finalCoinsInCirculation === "number"
		? season.finalCoinsInCirculation
		: season.coinsInCirculation;
	const remainingEl = card.querySelector("[data-season-remaining]");
	const priceEl = card.querySelector("[data-season-price]");
	const priceLabelEl = card.querySelector("[data-season-price-label]");
	const coinsEl = card.querySelector("[data-season-coins]");
	const emissionEl = card.querySelector("[data-season-emission]");
	const pressureEl = card.querySelector("[data-season-pressure]");
	if (remainingEl) {
		remainingEl.innerText = ended
			? "Season ended ‚Äî read-only."
			: `${formatRemaining(season.secondsRemaining || 0)} remaining`;
	}
	if (priceEl) priceEl.innerText = formatMicrocoinsToCoinsDisplay(starPriceValue);
	if (priceLabelEl) priceLabelEl.innerText = ended ? "Final star price snapshot" : "Star price";
	if (coinsEl) coinsEl.innerText = formatCoinsInCirculationForSeason({ ...season, coinsInCirculation: coinsValue });
	if (emissionEl) emissionEl.innerText = formatEmissionValue(season.coinEmissionPerMinute, ended);
	if (pressureEl) pressureEl.innerText = formatPressureValue(season.marketPressure, ended);
	updateSeasonActionsState(season);
}

function updateSeasonActionsState(season) {
	const ended = seasonStatusValue(season) === "ended";
	const dailyBtn = document.getElementById("claim-daily");
	const activityBtn = document.getElementById("claim-activity");
	if (dailyBtn) dailyBtn.disabled = ended;
	if (activityBtn) activityBtn.disabled = ended;
	if (actionsStatus) {
		actionsStatus.innerText = ended ? "Season ended ‚Äî read-only." : "";
	}
	const card = document.querySelector(`[data-season-id="${season?.seasonId}"]`);
	if (!card) return;
	const seasonActions = card.querySelector(".season-actions");
	if (!seasonActions) return;
	if (ended) {
		seasonActions.innerHTML = "<div class='label'>Season ended ‚Äî read-only.</div>";
		return;
	}
	const buyBtn = seasonActions.querySelector(".buy-star-btn");
	const qtyInput = seasonActions.querySelector(".bulk-qty");
	if (buyBtn) buyBtn.disabled = false;
	if (qtyInput) qtyInput.disabled = false;
}

function applyLiveSnapshot(payload) {
	if (!payload || !payload.season) return;
	updateSeasonSnapshot(payload.season);
	updateSeasonCard(payload.season);
	if (payload.authenticated && typeof payload.playerCoins === "number" && typeof payload.playerStars === "number") {
		playerCoins = payload.playerCoins;
		playerStars = payload.playerStars;
		const displayCoins = formatMicrocoinsToCoins(playerCoins);
		coinsDiv.innerText = `Coins: ${displayCoins}`;
		starsDiv.innerText = `Stars: ${playerStars}`;
		statPill.innerText = `${displayCoins} coins ¬∑ ${playerStars} stars`;
	}
}

function connectLiveStream() {
	if (liveEventSource) return;
	try {
		liveEventSource = new EventSource("/events");
		liveEventSource.addEventListener("snapshot", (event) => {
			try {
				const payload = JSON.parse(event.data);
				applyLiveSnapshot(payload);
				updateLiveStatus("live", "Live updates");
			} catch (e) {}
		});
		liveEventSource.onopen = () => updateLiveStatus("live", "Live updates");
		liveEventSource.onerror = () => updateLiveStatus("reconnecting", "Reconnecting");
	} catch (e) {
		updateLiveStatus("offline", "Offline");
	}
}

function disconnectLiveStream() {
	if (liveEventSource) {
		liveEventSource.close();
		liveEventSource = null;
	}
	updateLiveStatus("offline", "Offline");
}

// Bootstrap season readiness gate
async function waitForBootstrapSeason() {
	// If already resolved, return immediately
	if (bootstrapGateResolved) {
		return bootstrapSeasonReady;
	}

	// Check if season is ready by fetching /seasons endpoint
	try {
		const result = await apiFetchJson("/seasons", {}, 2500);
		const data = result.data || {};
		
		// Check if we have season data and it's valid
		bootstrapSeasonReady = data.seasons && data.seasons.length > 0;
		bootstrapGateResolved = true;
		
		// Clear timeout if it was set
		if (bootstrapTimeoutId) {
			clearTimeout(bootstrapTimeoutId);
			bootstrapTimeoutId = null;
		}
		
		// Remove bootstrap message
		if (authStatus) {
			authStatus.innerText = "Log in to save your profile.";
		}
		
		return bootstrapSeasonReady;
	} catch (e) {
		// If fetch fails, treat as season not ready
		bootstrapSeasonReady = false;
		bootstrapGateResolved = false;
		
		// Set timeout if not already set
		if (!bootstrapTimeoutId) {
			setBootstrapTimeout();
		}
		
		return false;
	}
}

// Set 15-second timeout for bootstrap
function setBootstrapTimeout() {
	if (bootstrapTimeoutId) return;
	
	bootstrapTimeoutId = setTimeout(() => {
		bootstrapTimeoutId = null;
		bootstrapGateResolved = true;
		bootstrapSeasonReady = false;
		
		// Show timeout message
		if (authStatus) {
			authStatus.innerHTML = '<div style="color:#fecaca;">Season is still initializing.<br>Please refresh the page in a moment.</div>';
		}
		
		// Disable login button and inputs
		const loginBtn = document.getElementById("login-btn");
		const usernameInput = document.getElementById("username");
		const passwordInput = document.getElementById("password");
		
		if (loginBtn) loginBtn.disabled = true;
		if (usernameInput) usernameInput.disabled = true;
		if (passwordInput) passwordInput.disabled = true;
	}, 15000);
}

async function loadAuth() {
	// Show bootstrap message while waiting for season readiness
	if (!bootstrapGateResolved) {
		authStatus.innerText = "Preparing the season‚Ä¶";
		authForms.style.display = "none";
		logoutBtn.style.display = "none";
		
		// Disable all login inputs while bootstrapping
		const usernameInput = document.getElementById("username");
		const passwordInput = document.getElementById("password");
		const loginBtn = document.getElementById("login-btn");
		const signupLink = document.getElementById("signup-link");
		
		if (usernameInput) usernameInput.disabled = true;
		if (passwordInput) passwordInput.disabled = true;
		if (loginBtn) loginBtn.disabled = true;
		
		// Start waiting for season readiness
		setBootstrapTimeout(); // Set the 15-second timeout
		await waitForBootstrapSeason();
		
		// If still not ready after waiting, return early
		// (the timeout will handle the UI state)
		if (!bootstrapSeasonReady) {
			return;
		}
	}
	
	// Now proceed with auth check only after bootstrap is ready
	const result = await apiFetchJson("/auth/me", {}, 2500);
	const data = result.data || { ok: false };
	if (!data.ok) {
		currentUser = null;
		authStatus.innerText = "Log in to save your profile.";
		authForms.style.display = "block";
		logoutBtn.style.display = "none";
		playerPanels.style.display = "none";
		seasonSnapshot.style.display = "none";
		actionsCard.style.display = "none";
		statPill.style.display = "none";
		signupLink.style.display = "inline";
		moderatorLink.style.display = "none";
		adminLink.style.display = "none";
		notificationsCache = [];
		updateNotificationBadge(0);
		setNotificationViewport(false);
		document.getElementById("seasons").style.display = "none";
		document.getElementById("locked-message").innerText = "Log in to access seasons.";
		
		// Enable login inputs once bootstrap is complete
		const usernameInput = document.getElementById("username");
		const passwordInput = document.getElementById("password");
		const loginBtn = document.getElementById("login-btn");
		
		if (usernameInput) usernameInput.disabled = false;
		if (passwordInput) passwordInput.disabled = false;
		if (loginBtn) loginBtn.disabled = false;
		
		connectLiveStream();
		return;
	}

	currentUser = data;
	authStatus.innerText = `Logged in as ${data.displayName}`;
	authForms.style.display = "none";
	logoutBtn.style.display = "block";
	profileName.innerText = `@${data.username}`;
	profileRole.innerText = `Role: ${data.role || "user"}`;
	profileDisplay.value = data.displayName;
	await loadProfile();
	playerPanels.style.display = "grid";
	seasonSnapshot.style.display = "block";
	actionsCard.style.display = "block";
	statPill.style.display = "inline-flex";
	signupLink.style.display = "none";
	moderatorLink.style.display = (data.isModerator || data.isAdmin) ? "inline" : "none";
	adminLink.style.display = data.isAdmin ? "inline" : "none";
	document.getElementById("seasons").style.display = "grid";
	document.getElementById("locked-message").innerText = "";
}

function setNotificationViewport(open) {
	notificationPanelOpen = open;
	if (!notificationViewport) return;
	if (open) {
		notificationViewport.style.display = "block";
		notificationViewport.setAttribute("aria-hidden", "false");
		if (!currentUser && notificationEmpty) {
			notificationEmpty.innerText = "Log in to view notifications.";
			notificationEmpty.style.display = "block";
		}
		renderNotificationList();
	} else {
		notificationViewport.style.display = "none";
		notificationViewport.setAttribute("aria-hidden", "true");
	}
}

if (notificationBell) {
	notificationBell.addEventListener("click", (event) => {
		event.stopPropagation();
		setNotificationViewport(!notificationPanelOpen);
	});
}

document.addEventListener("click", (event) => {
	if (!notificationPanelOpen) return;
	const target = event.target;
	if (notificationViewport && notificationViewport.contains(target)) return;
	if (notificationBell && notificationBell.contains(target)) return;
	setNotificationViewport(false);
});

async function pingActivity() {
	if (!currentUser) return;
	try {
		await apiFetch("/activity", { method: "POST", body: JSON.stringify({}) });
	} catch (e) {}
}

function startActiveLoops() {
	if (playerRefreshInterval || seasonRefreshInterval || activityPingInterval) {
		return;
	}
	refreshPlayer();
	loadSeasons();
	refreshNotifications();
	loadNotificationSettings();
	pingActivity();
	connectLiveStream();
	connectNotificationStream();
	playerRefreshInterval = setInterval(() => {
		if (currentUser) refreshPlayer();
	}, 10000);
	seasonRefreshInterval = setInterval(() => {
		if (currentUser) loadSeasons();
	}, 15000);
	activityPingInterval = setInterval(() => {
		if (currentUser) pingActivity();
	}, 20000);
}

function stopActiveLoops(options = {}) {
	if (playerRefreshInterval) clearInterval(playerRefreshInterval);
	if (seasonRefreshInterval) clearInterval(seasonRefreshInterval);
	if (activityPingInterval) clearInterval(activityPingInterval);
	playerRefreshInterval = null;
	seasonRefreshInterval = null;
	activityPingInterval = null;
	disconnectLiveStream();
	if (!options.keepNotifications) {
		disconnectNotificationStream();
	}
}

function handleVisibility() {
	if (document.hidden) {
		stopActiveLoops({ keepNotifications: true });
		stopAdminLoops();
		return;
	}
	if (currentUser) {
		startActiveLoops();
	}
	if (currentUser && currentUser.isAdmin && isAdminRoute()) {
		startAdminLoops();
	}
}

async function refreshPlayer() {
	if (!currentUser) return;
	const res = await apiFetch("/player");
	if (res.status === 401) return;
	const data = await res.json();
	playerCoins = data.playerCoins || 0;
	playerStars = data.playerStars || 0;
	const displayCoins = formatMicrocoinsToCoins(playerCoins);
	coinsDiv.innerText = `Coins: ${displayCoins}`;
	starsDiv.innerText = `Stars: ${playerStars}`;
	statPill.innerText = `${displayCoins} coins ¬∑ ${playerStars} stars`;
}

async function loadProfile() {
	if (!currentUser) return;
	const res = await apiFetch("/profile");
	if (!res.ok) return;
	const data = await res.json();
	if (!data.ok) return;
	profileDisplay.value = data.displayName || "";
	profileEmail.value = data.email || "";
	profilePronouns.value = data.pronouns || "";
	profileLocation.value = data.location || "";
	profileWebsite.value = data.website || "";
	profileAvatar.value = data.avatarUrl || "";
	profileBio.value = data.bio || "";
	profileAvatarImg.src = data.avatarUrl || "https://placehold.co/64x64?text=User";
}

function attachBuyStarHandler(buyButton, seasonCardDiv, season) {
	if (!buyButton) return;
	const qtyInput = seasonCardDiv.querySelector(".bulk-qty");
	const quoteEl = seasonCardDiv.querySelector(".bulk-quote");
	const warningEl = seasonCardDiv.querySelector(".bulk-warning");
	const breakdownEl = seasonCardDiv.querySelector(".bulk-breakdown");
	let lastQuote = null;
	
	const refreshQuote = async () => {
		if (seasonStatusValue(currentSeasonSnapshot || season) === "ended") {
			if (quoteEl) quoteEl.innerText = "Season ended.";
			return;
		}
		if (!qtyInput) return;
		const qty = Math.max(1, parseInt(qtyInput.value, 10) || 1);
		if (quoteEl) quoteEl.innerText = "";
		if (warningEl) warningEl.innerText = "";
		if (breakdownEl) breakdownEl.innerText = "";
		const res = await apiFetch("/buy-star/quote", {
			method: "POST",
			body: JSON.stringify({ seasonId: season.seasonId, quantity: qty })
		});
		const data = await res.json();
		if (!data.ok) {
			lastQuote = null;
			if (quoteEl) quoteEl.innerText = data.error || "Quote failed";
			return;
		}
		lastQuote = data;
		const perStarPrice = typeof data.finalStarPrice === "number"
			? formatMicrocoinsToCoins(data.finalStarPrice)
			: (data.breakdown && data.breakdown.length > 0 ? formatMicrocoinsToCoins(data.breakdown[data.breakdown.length - 1].finalPrice) : null);
		const totalCost = formatMicrocoinsToCoins(data.totalCoinsSpent);
		if (quoteEl) {
			if (totalCost != null && perStarPrice != null) {
				quoteEl.innerText = `Total cost: ${totalCost} coins ¬∑ Per-star: ${perStarPrice} coins`;
			} else if (totalCost != null) {
				quoteEl.innerText = `Total cost: ${totalCost} coins`;
			} else if (perStarPrice != null) {
				quoteEl.innerText = `Per-star: ${perStarPrice} coins`;
			} else {
				quoteEl.innerText = "";
			}
		}
		if (warningEl) warningEl.innerText = data.warning || "";
		if (breakdownEl) breakdownEl.innerText = "";
	};
	
	if (qtyInput) {
		qtyInput.addEventListener("input", refreshQuote);
		refreshQuote();
	}

	buyButton.addEventListener("click", async () => {
		if (seasonStatusValue(currentSeasonSnapshot || season) === "ended") {
			setToast("Season ended. Purchases are disabled.", "error");
			return;
		}
		const qty = Math.max(1, parseInt(qtyInput?.value, 10) || 1);
		await refreshQuote();
		if (qty > 1) {
			const totalCostMicro = lastQuote && typeof lastQuote.totalCoinsSpent === "number" ? lastQuote.totalCoinsSpent : null;
			const totalCost = formatMicrocoinsToCoins(totalCostMicro);
			const confirmMessage = totalCost != null
				? `Confirm purchase of ${qty} stars for ${totalCost} coins?`
				: `Confirm purchase of ${qty} stars?`;
			if (!confirm(confirmMessage)) {
				return;
			}
		}
		const res = await apiFetch("/buy-star", {
			method: "POST",
			body: JSON.stringify({ seasonId: season.seasonId, quantity: qty })
		});
		const data = await res.json();
		if (!data.ok) {
			setToast(data.error || "Purchase failed", "error");
			return;
		}
		playerCoins = data.playerCoins;
		playerStars = data.playerStars;
		const displayCoins = formatMicrocoinsToCoins(playerCoins);
		coinsDiv.innerText = `Coins: ${displayCoins}`;
		starsDiv.innerText = `Stars: ${playerStars}`;
		statPill.innerText = `${displayCoins} coins ¬∑ ${playerStars} stars`;
		const label = data.starsPurchased && data.starsPurchased > 1
			? `Bought ${data.starsPurchased} stars.`
			: "Star purchased.";
		setToast(label, "success");
		track("buy_star", { seasonId: season.seasonId, quantity: data.starsPurchased || 1 });
		refreshQuote();
	});
}

async function loadSeasons() {
	const container = document.getElementById("seasons");
	if (!container) return;
	const result = await apiFetchJson("/seasons", {}, 2500);
	const data = result.data;
	if (!data) {
		container.innerHTML = "<div class='card'>Unable to load seasons.</div>";
		return;
	}
	container.innerHTML = "";
	
	// Use the recommended season from server, or first available season (Alpha: single season only)
	const activeSeason = data.seasons && data.seasons.length > 0
		? (data.seasons.find(s => s.seasonId === data.recommendedSeasonId) || data.seasons[0])
		: null;
	
	if (!activeSeason) {
		container.innerHTML = "<div class='card'>Season unavailable.</div>";
		return;
	}

	[activeSeason].forEach(season => {
		const div = document.createElement("div");
		const isJoined = Boolean(currentUser);
		const isThisSeasonJoined = isJoined;
		const ended = seasonStatusValue(season) === "ended";
		const starPriceMicro = ended && typeof season.finalStarPrice === "number"
			? season.finalStarPrice
			: season.currentStarPrice;
		const starPrice = formatMicrocoinsToCoins(starPriceMicro);
		const remainingLabel = ended
			? "Season ended ‚Äî read-only."
			: `${formatRemaining(season.secondsRemaining)} remaining`;
		const starPriceLabel = ended ? "Final star price snapshot" : "Star price";
		updateSeasonSnapshot(season);

		div.className = "card season-card";
		div.dataset.seasonId = season.seasonId;
		if (season.seasonId === data.recommendedSeasonId) {
			div.classList.add("recommended");
		}

		div.innerHTML = `
			<div class="season-card-header">
				<div>
					<div class="label">Active Season</div>
					<div class="stat-value" data-season-remaining>${remainingLabel}</div>
				</div>
				${season.seasonId === data.recommendedSeasonId ? '<span class="badge accent">Active</span>' : ''}
			</div>
			<div class="season-card-grid">
				<div class="metric">
					<div class="label" data-season-price-label>${starPriceLabel}</div>
					<div class="stat-value" data-season-price>${starPrice !== null ? starPrice + ' coins' : '--'}</div>
				</div>
				<div class="metric">
					<div class="label">Coins in circulation</div>
					<div class="stat-value" data-season-coins>${formatCoinsInCirculationForSeason(season)}</div>
				</div>
				<div class="metric">
					<div class="label">Inflation pressure</div>
					<div class="stat-value" data-season-emission>${formatEmissionValue(season.coinEmissionPerMinute, ended)}</div>
				</div>
				<div class="metric">
					<div class="label">Market pressure</div>
					<div class="stat-value" data-season-pressure>${formatPressureValue(season.marketPressure, ended)}</div>
				</div>
			</div>
			<div class="season-actions">
				${isThisSeasonJoined
					? (ended
						? "<div class='label'>Season ended ‚Äî read-only.</div>"
						: `
							<div class="row" style="margin-top:0.35rem;">
								<label class="label">Qty</label>
								<input class="bulk-qty" type="number" min="1" max="${bulkStarMax}" value="1" />
								<button class="buy-star-btn primary">Buy Stars</button>
							</div>
							<div class="label bulk-quote"></div>
							<div class="label bulk-warning"></div>
							<div class="label bulk-breakdown"></div>
						`)
					: "<div class='label'>Log in to join the season.</div>"
				}
			</div>
		`;

		const buyButton = div.querySelector(".buy-star-btn");
		if (buyButton) {
			attachBuyStarHandler(buyButton, div, season);
		}

		container.appendChild(div);
		updateSeasonActionsState(season);
	});
}

function setToast(message, type) {
	toast.innerText = message;
	toast.className = `toast ${type || ""}`;
	toast.style.display = "block";
	setTimeout(() => {
		toast.style.display = "none";
	}, 2500);
}

function initLeaderboard() {
	leaderboardInitialized = true;
	document.getElementById("leaderboard-apply").addEventListener("click", () => {
		leaderboardPage = 1;
		loadLeaderboard();
	});
	document.getElementById("leaderboard-prev").addEventListener("click", () => {
		if (leaderboardPage > 1) {
			leaderboardPage -= 1;
			loadLeaderboard();
		}
	});
	document.getElementById("leaderboard-next").addEventListener("click", () => {
		leaderboardPage += 1;
		loadLeaderboard();
	});
	document.getElementById("leaderboard-search").addEventListener("keydown", (event) => {
		if (event.key === "Enter") {
			leaderboardPage = 1;
			loadLeaderboard();
		}
	});
}

async function loadLeaderboard() {
	if (!leaderboardResults) return;
	const params = new URLSearchParams();
	const searchValue = document.getElementById("leaderboard-search").value.trim();
	const includeBots = document.getElementById("leaderboard-include-bots").checked;
	const botOnly = document.getElementById("leaderboard-bot-only").checked;
	const sort = document.getElementById("leaderboard-sort").value;
	const pageSize = parseInt(document.getElementById("leaderboard-page-size").value, 10) || 50;

	if (searchValue) params.set("q", searchValue);
	params.set("includeBots", includeBots ? "true" : "false");
	params.set("botOnly", botOnly ? "true" : "false");
	params.set("sort", sort);
	params.set("page", `${leaderboardPage}`);
	params.set("pageSize", `${pageSize}`);

	const res = await apiFetch(`/leaderboard?${params.toString()}`);
	const data = await res.json();
	if (!data.results) {
		leaderboardResults.innerHTML = "<div class='card'>Unable to load leaderboard.</div>";
		return;
	}

	if (data.results.length === 0) {
		leaderboardResults.innerHTML = "<div class='card'>No results found.</div>";
		if (leaderboardPageLabel) leaderboardPageLabel.innerText = `Page ${data.page} of 1`;
		return;
	}

	const totalPages = Math.max(1, Math.ceil((data.total || 0) / data.pageSize));
	if (leaderboardPageLabel) leaderboardPageLabel.innerText = `Page ${data.page} of ${totalPages}`;

	leaderboardResults.innerHTML = data.results.map(entry => {
		const botBadge = entry.isBot ? `<span class="badge bot">BOT</span>` : "";
		const botProfile = entry.isBot && entry.botProfile ? `<div class="label">${entry.botProfile}</div>` : "";
		const lastStar = entry.lastStarAcquiredAt ? new Date(entry.lastStarAcquiredAt).toLocaleString() : "-";
		return `
			<div class="card">
				<div class="row" style="justify-content:space-between;">
					<div><strong>#${entry.rank}</strong> ${entry.displayName}</div>
					${botBadge}
				</div>
				<div class="label">Stars ${entry.stars} ¬∑ Coins spent ${entry.coinsSpentLifetime}</div>
				<div class="label">Last star: ${lastStar}</div>
				${botProfile}
			</div>
		`;
	}).join("");
}

function humanizeCategory(category) {
	return (category || "system")
		.replace("_", " ")
		.replace(/\b\w/g, (m) => m.toUpperCase());
}

function renderNotificationSettings() {
	if (!notificationSettingsList) return;
	notificationSettingsList.innerHTML = notificationCategories.map(category => {
		const setting = notificationSettings[category] || { enabled: true, pushEnabled: false };
		return `
			<div class="notification-setting-row">
				<div>${humanizeCategory(category)}</div>
				<label>
					<input type="checkbox" data-category="${category}" data-channel="inapp" ${setting.enabled ? "checked" : ""} />
					<span>In-app</span>
				</label>
				<label>
					<input type="checkbox" data-category="${category}" data-channel="push" ${setting.pushEnabled ? "checked" : ""} />
					<span>Push</span>
				</label>
			</div>
		`;
	}).join("");

	[...notificationSettingsList.querySelectorAll("input[type='checkbox']")].forEach(input => {
		input.addEventListener("change", async () => {
			const category = input.getAttribute("data-category");
			const channel = input.getAttribute("data-channel");
			const current = notificationSettings[category] || { enabled: true, pushEnabled: false };
			if (channel === "push") {
				if (input.checked) {
					const allowed = await ensurePushPermission();
					if (!allowed) {
						input.checked = false;
						setToast("Push notifications are blocked in your browser.", "error");
						return;
					}
				}
				current.pushEnabled = input.checked;
			} else {
				current.enabled = input.checked;
			}
			notificationSettings[category] = current;
			scheduleNotificationSettingsSave();
		});
	});
}

function scheduleNotificationSettingsSave() {
	if (notificationSettingsSaveTimer) {
		clearTimeout(notificationSettingsSaveTimer);
	}
	notificationSettingsSaveTimer = setTimeout(() => {
		saveNotificationSettings();
	}, 500);
}

async function loadNotificationSettings() {
	if (!currentUser) return;
	try {
		const res = await apiFetch("/notifications/settings");
		const data = await res.json();
		if (!data.ok) return;
		notificationSettings = {};
		(data.settings || []).forEach(item => {
			notificationSettings[item.category] = {
				enabled: item.enabled !== false,
				pushEnabled: item.pushEnabled === true
			};
		});
		renderNotificationSettings();
	} catch (e) {}
}

async function saveNotificationSettings() {
	if (!currentUser) return;
	const payload = {
		categories: notificationCategories.map(category => ({
			category,
			enabled: notificationSettings[category]?.enabled !== false,
			pushEnabled: notificationSettings[category]?.pushEnabled === true
		}))
	};
	try {
		await apiFetch("/notifications/settings", {
			method: "POST",
			body: JSON.stringify(payload)
		});
		await refreshNotifications();
	} catch (e) {}
}

async function ensurePushPermission() {
	if (!("Notification" in window)) return false;
	if (Notification.permission === "granted") return true;
	if (Notification.permission === "denied") return false;
	const result = await Notification.requestPermission();
	return result === "granted";
}

function escapeHtml(text) {
	return String(text || "")
		.replace(/&/g, "&amp;")
		.replace(/</g, "&lt;")
		.replace(/>/g, "&gt;")
		.replace(/\"/g, "&quot;")
		.replace(/'/g, "&#39;");
}

function formatRelativeTime(value) {
	const date = new Date(value);
	if (Number.isNaN(date.getTime())) return "";
	const diffSeconds = Math.max(0, Math.floor((Date.now() - date.getTime()) / 1000));
	if (diffSeconds < 60) return "Just now";
	const minutes = Math.floor(diffSeconds / 60);
	if (minutes < 60) return `${minutes}m ago`;
	const hours = Math.floor(minutes / 60);
	if (hours < 24) return `${hours}h ago`;
	const days = Math.floor(hours / 24);
	if (days === 1) return "Yesterday";
	return `${days}d ago`;
}

function iconForCategory(category) {
	switch ((category || "system").toLowerCase()) {
	case "economy":
		return "ü™ô";
	case "player_action":
		return "‚ú®";
	case "market":
		return "üìà";
	case "abuse":
		return "üõ°Ô∏è";
	case "admin":
		return "üß≠";
	default:
		return "üîî";
	}
}

function updateNotificationBadge(count) {
	if (!notificationBadge) return;
	if (count > 0) {
		notificationBadge.style.display = "inline-flex";
		notificationBadge.innerText = `${count}`;
	} else {
		notificationBadge.style.display = "none";
	}
	if (notificationUnreadLabel) {
		notificationUnreadLabel.innerText = count > 0 ? `${count} unread` : "";
	}
}

function renderNotificationList() {
	if (!notificationList) return;
	const unreadCount = notificationsCache.filter(item => !item.isRead).length;
	updateNotificationBadge(unreadCount);
	if (notificationsCache.length === 0) {
		notificationList.innerHTML = "";
		if (notificationEmpty) {
			notificationEmpty.innerText = "No notifications yet.";
			notificationEmpty.style.display = "block";
		}
		return;
	}
	if (notificationEmpty) notificationEmpty.style.display = "none";
	notificationList.innerHTML = notificationsCache.map(item => {
		const stateClass = item.isRead ? "read" : "unread";
		const link = item.link || "";
		return `
			<div class="notification-item ${stateClass}" data-id="${item.id}" data-link="${link}">
				<div class="notification-icon">${iconForCategory(item.category)}</div>
				<div class="notification-body">
					<div class="notification-message">${escapeHtml(item.message)}</div>
					<div class="notification-time">${formatRelativeTime(item.createdAt)}</div>
				</div>
				<button class="notification-trash" type="button" aria-label="Delete notification" data-id="${item.id}">üóë</button>
			</div>
		`;
	}).join("");

	if (!renderNotificationList.initialized) {
		renderNotificationList.initialized = true;
		notificationList.addEventListener("click", async (event) => {
			const deleteBtn = event.target.closest(".notification-trash");
			if (deleteBtn) {
				event.stopPropagation();
				const id = parseInt(deleteBtn.getAttribute("data-id"), 10);
				if (!id) return;
				await apiFetch("/notifications/delete", {
					method: "POST",
					body: JSON.stringify({ ids: [id] })
				});
				notificationsCache = notificationsCache.filter(item => item.id !== id);
				renderNotificationList();
				return;
			}

			const itemEl = event.target.closest(".notification-item");
			if (!itemEl) return;
			const id = parseInt(itemEl.getAttribute("data-id"), 10);
			const link = itemEl.getAttribute("data-link") || "";
			const item = notificationsCache.find(entry => entry.id === id);
			if (item && !item.isRead) {
				item.isRead = true;
				renderNotificationList();
				await apiFetch("/notifications/ack", {
					method: "POST",
					body: JSON.stringify({ ids: [id] })
				});
			}
			if (!link) return;
			if (link.startsWith("http")) {
				window.location.href = link;
				return;
			}
			if (link.startsWith("#/")) {
				location.hash = link;
				return;
			}
			if (link.startsWith("/")) {
				location.hash = `#${link}`;
				return;
			}
			location.hash = `#/${link}`;
		});
	}
}

function maybeSendPush(item) {
	if (!item || item.isRead) return;
	const category = (item.category || "system").toLowerCase();
	const setting = notificationSettings[category];
	if (!setting || !setting.pushEnabled) return;
	if (!("Notification" in window)) return;
	if (Notification.permission !== "granted") return;
	if (!document.hidden && notificationPanelOpen) return;
	try {
		new Notification("Too Many Coins", { body: item.message || "New notification" });
	} catch (e) {}
}

function upsertNotification(item, fromStream) {
	if (!item || !item.id) return;
	const index = notificationsCache.findIndex(entry => entry.id === item.id);
	if (index >= 0) {
		notificationsCache[index] = item;
	} else {
		notificationsCache.unshift(item);
	}
	notificationsCache.sort((a, b) => new Date(b.createdAt) - new Date(a.createdAt));
	lastNotificationId = Math.max(lastNotificationId, item.id || 0);
	renderNotificationList();
	if (fromStream) {
		maybeSendPush(item);
	}
}

function connectNotificationStream() {
	if (!currentUser || notificationEventSource) return;
	const afterParam = lastNotificationId > 0 ? `?after=${lastNotificationId}` : "";
	notificationEventSource = new EventSource(`/notifications/stream${afterParam}`);
	notificationEventSource.addEventListener("notification", (event) => {
		try {
			const item = JSON.parse(event.data);
			upsertNotification(item, true);
		} catch (e) {
			refreshNotifications();
		}
	});
	notificationEventSource.onerror = () => {};
}

function disconnectNotificationStream() {
	if (!notificationEventSource) return;
	notificationEventSource.close();
	notificationEventSource = null;
}

async function refreshNotifications() {
	if (!currentUser) {
		notificationsCache = [];
		updateNotificationBadge(0);
		if (notificationEmpty) {
			notificationEmpty.innerText = "Log in to view notifications.";
			notificationEmpty.style.display = "block";
		}
		return;
	}
	const res = await apiFetch("/notifications");
	const data = await res.json();
	if (!data.ok) {
		return;
	}
	const items = data.notifications || [];
	notificationsCache = items.slice().sort((a, b) => new Date(b.createdAt) - new Date(a.createdAt));
	lastNotificationId = items.reduce((maxId, item) => Math.max(maxId, item.id || 0), lastNotificationId);
	renderNotificationList();
}

function setView(viewId) {
	views.forEach(view => view.classList.remove("active"));
	const nextView = document.getElementById(viewId);
	if (nextView) {
		nextView.classList.add("active");
	}
}

function initCollapsibleCards() {
	if (initCollapsibleCards.initialized) return;
	initCollapsibleCards.initialized = true;
	const cards = Array.from(document.querySelectorAll(".card[data-collapsible='true']"));
	cards.forEach(card => {
		const toggleBtn = card.querySelector(".toggle-btn");
		const body = card.querySelector(".card-body");
		if (!toggleBtn || !body) return;
		toggleBtn.addEventListener("click", () => {
			const collapsed = card.classList.toggle("collapsed");
			toggleBtn.innerText = collapsed ? "Show" : "Hide";
		});
	});
}

function initAdmin() {
	adminInitialized = true;
	const nav = document.getElementById("admin-nav");
	if (!nav) return;
	const buttons = Array.from(nav.querySelectorAll("button[data-target]"));
	buttons.forEach((button) => {
		button.addEventListener("click", () => {
			const targetId = button.getAttribute("data-target");
			if (!targetId) return;
			const section = document.getElementById(targetId);
			if (section) {
				section.scrollIntoView({ behavior: "smooth", block: "start" });
			}
			buttons.forEach(btn => btn.classList.toggle("active", btn === button));
		});
	});
	if (buttons[0]) buttons[0].classList.add("active");
	const searchBtn = document.getElementById("admin-player-search");
	const searchInput = document.getElementById("admin-player-query");
	const trustSelect = document.getElementById("admin-player-trust");
	if (searchBtn) {
		searchBtn.disabled = false;
		searchBtn.addEventListener("click", () => loadAdminPlayerSearch());
	}
	if (searchInput) {
		searchInput.addEventListener("keydown", (event) => {
			if (event.key === "Enter") {
				loadAdminPlayerSearch();
			}
		});
	}
	if (trustSelect) {
		trustSelect.addEventListener("change", () => loadAdminPlayerSearch());
	}
	const auditBtn = document.getElementById("admin-audit-run");
	const auditInput = document.getElementById("admin-audit-search");
	if (auditBtn) {
		auditBtn.disabled = false;
		auditBtn.addEventListener("click", () => loadAdminAuditLog());
	}
	if (auditInput) {
		auditInput.addEventListener("keydown", (event) => {
			if (event.key === "Enter") {
				loadAdminAuditLog();
			}
		});
	}
	if (adminDebugToggle) {
		adminDebugToggle.checked = isDebugEnabled();
		adminDebugToggle.addEventListener("change", () => {
			localStorage.setItem("tmc_debug_banner", adminDebugToggle.checked ? "true" : "false");
			updateDebugVisibility();
		});
	}
	const bugRefreshBtn = document.getElementById("admin-bug-refresh");
	if (bugRefreshBtn) {
		bugRefreshBtn.addEventListener("click", () => loadAdminBugReports());
	}
	updateDebugVisibility();
}

function refreshAdminView() {
	const adminShell = document.getElementById("admin-shell");
	const adminDenied = document.getElementById("admin-access-denied");
	if (!currentUser || !currentUser.isAdmin) {
		if (adminShell) adminShell.style.display = "none";
		if (adminDenied) adminDenied.style.display = "block";
		return;
	}
	if (adminDenied) adminDenied.style.display = "none";
	if (adminShell) adminShell.style.display = "grid";
	loadAdminPlayerSearch();
	loadAdminAuditLog();
	loadAdminBugReports();
}

function setIndicator(el, text, level) {
	if (!el) return;
	el.classList.remove("ok", "warn", "danger");
	if (level) el.classList.add(level);
	el.innerText = text;
}

function abuseSignalState(flags, events, severe) {
	if (severe >= 5 || flags >= 25) return { label: "Critical", level: "danger" };
	if (events >= 10 || flags >= 5) return { label: "Elevated", level: "warn" };
	return { label: "Low", level: "ok" };
}

function economyState(pressure) {
	if (typeof pressure !== "number" || !isFinite(pressure)) {
		return { label: "Stable", level: "ok" };
	}
	if (pressure >= 1.3) return { label: "Pressured", level: "warn" };
	return { label: "Stable", level: "ok" };
}

function formatSeasonDay(season) {
	const totalDays = typeof season?.totalDays === "number" && isFinite(season.totalDays) ? season.totalDays : null;
	const dayIndex = typeof season?.dayIndex === "number" && isFinite(season.dayIndex) ? season.dayIndex : null;
	if (totalDays && dayIndex) {
		const clampedDay = Math.min(totalDays, Math.max(1, dayIndex));
		return `${clampedDay} / ${totalDays}`;
	}
	return "--";
}

function seasonStatusLabelAdmin(season) {
	return seasonStatusLabel(season);
}

function updateAdminControlVisibility(season) {
	const ended = seasonStatusValue(season) === "ended";
	const totalDays = typeof season?.totalDays === "number" && isFinite(season.totalDays) ? season.totalDays : null;
	const isAlpha = totalDays !== null && totalDays <= 21;
	const controls = Array.from(document.querySelectorAll("[data-admin-controls]"));
	controls.forEach((el) => {
		el.style.display = (ended || isAlpha) ? "none" : "block";
	});
}

function formatToggleStatus(item) {
	if (!item) return "--";
	const statusMap = {
		enabled: "Enabled",
		disabled: "Disabled",
		"always-on": "Always-on",
		"not-configured": "Not configured"
	};
	const status = statusMap[item.status] || item.status || "Unknown";
	const count = typeof item.eventCount === "number" ? item.eventCount : 0;
	const last = item.lastTriggeredAt ? formatRelativeTime(item.lastTriggeredAt) : "No triggers";
	return `${status} ¬∑ ${count} events ¬∑ ${last}`;
}

async function loadAdminAntiCheat() {
	if (!currentUser || !currentUser.isAdmin) return;
	try {
		const res = await apiFetch("/admin/anti-cheat");
		const data = await res.json();
		if (!data.ok) return;
		const toggles = data.toggles || [];
		const byKey = toggles.reduce((acc, item) => {
			acc[item.key] = item;
			return acc;
		}, {});
		if (adminToggleIP) adminToggleIP.innerText = formatToggleStatus(byKey.ip_enforcement);
		if (adminToggleCluster) adminToggleCluster.innerText = formatToggleStatus(byKey.clustering_detection);
		if (adminToggleThrottle) adminToggleThrottle.innerText = formatToggleStatus(byKey.automatic_throttling);
		if (adminToggleTrade) adminToggleTrade.innerText = formatToggleStatus(byKey.trade_tightening);
		if (adminToggleBots) adminToggleBots.innerText = formatToggleStatus(byKey.bot_detection);
		const sensitivity = data.sensitivity || {};
		if (adminSenseCluster) adminSenseCluster.innerText = sensitivity.clustering || "Not configured";
		if (adminSenseThrottle) adminSenseThrottle.innerText = sensitivity.throttle || "Not configured";
		if (adminSenseTrade) adminSenseTrade.innerText = sensitivity.trade || "Not configured";
		if (adminSenseFaucet) adminSenseFaucet.innerText = sensitivity.faucet || "Not configured";
		if (adminAbuseHeatmap) adminAbuseHeatmap.innerText = "Unavailable";
	} catch (e) {}
}

async function loadAdminPlayerSearch() {
	if (!currentUser || !currentUser.isAdmin) return;
	const query = document.getElementById("admin-player-query");
	const trust = document.getElementById("admin-player-trust");
	const results = document.getElementById("admin-player-results");
	const empty = document.getElementById("admin-player-empty");
	if (!query || !trust || !results || !empty) return;
	const searchValue = query.value.trim();
	const trustValue = trust.value.trim();
	if (!searchValue && !trustValue) {
		empty.innerText = "Enter a username, player ID, account ID, or trust status.";
		empty.style.display = "block";
		results.innerHTML = "";
		return;
	}
	const params = new URLSearchParams();
	if (searchValue) params.set("q", searchValue);
	if (trustValue) params.set("trust", trustValue);
	params.set("limit", "25");
	const res = await apiFetch(`/admin/player-search?${params.toString()}`);
	const data = await res.json();
	if (!data.ok) {
		empty.innerText = "Unable to load results.";
		empty.style.display = "block";
		results.innerHTML = "";
		return;
	}
	const items = data.items || [];
	if (!items.length) {
		empty.innerText = "No matching players found.";
		empty.style.display = "block";
		results.innerHTML = "";
		return;
	}
	empty.style.display = "none";
	results.innerHTML = items.map((item) => `
		<div class="card">
			<div class="row" style="justify-content:space-between;">
				<div><strong>${escapeHtml(item.displayName || item.username)}</strong> ¬∑ @${escapeHtml(item.username)}</div>
				<span class="badge">${escapeHtml(item.trustStatus || "normal")}</span>
			</div>
			<div class="label">Season ${escapeHtml(item.seasonId || "--")}</div>
			<div class="label">Player ID ${escapeHtml(item.playerId || "--")} ¬∑ Account ID ${escapeHtml(item.accountId || "--")}</div>
			<div class="label">Flag count ${item.flagCount || 0}</div>
		</div>
	`).join("");
}

async function loadAdminAuditLog() {
	if (!currentUser || !currentUser.isAdmin) return;
	const query = document.getElementById("admin-audit-search");
	const results = document.getElementById("admin-audit-results");
	const empty = document.getElementById("admin-audit-empty");
	if (!query || !results || !empty) return;
	const searchValue = query.value.trim();
	const params = new URLSearchParams();
	if (searchValue) params.set("q", searchValue);
	params.set("limit", "50");
	const res = await apiFetch(`/admin/audit-log?${params.toString()}`);
	const data = await res.json();
	if (!data.ok) {
		empty.innerText = "Unable to load audit log.";
		empty.style.display = "block";
		results.innerHTML = "";
		return;
	}
	const items = data.items || [];
	if (!items.length) {
		empty.innerText = "No audit entries yet.";
		empty.style.display = "block";
		results.innerHTML = "";
		return;
	}
	empty.style.display = "none";
	results.innerHTML = items.map((item) => {
		const actor = item.adminUsername ? `@${escapeHtml(item.adminUsername)}` : escapeHtml(item.adminAccount || "unknown");
		const reason = item.reason ? `Reason: ${escapeHtml(item.reason)}` : "";
		const when = item.createdAt ? formatRelativeTime(item.createdAt) : "";
		return `
			<div class="card">
				<div class="row" style="justify-content:space-between;">
					<div><strong>${escapeHtml(item.actionType || "action")}</strong> ¬∑ ${escapeHtml(item.scopeType)} ${escapeHtml(item.scopeId)}</div>
					<span class="badge">${actor}</span>
				</div>
				<div class="label">${reason}</div>
				<div class="label">${when}</div>
			</div>
		`;
	}).join("");
}

async function loadAdminBugReports() {
	if (!currentUser || !currentUser.isAdmin) return;
	const results = document.getElementById("admin-bug-results");
	const empty = document.getElementById("admin-bug-empty");
	if (!results || !empty) return;
	
	const params = new URLSearchParams();
	params.set("limit", "50");
	params.set("offset", "0");
	
	const res = await apiFetch(`/admin/bugs?${params.toString()}`);
	const data = await res.json();
	if (!data.ok) {
		empty.innerText = "Unable to load bug reports.";
		empty.style.display = "block";
		results.innerHTML = "";
		return;
	}
	const items = data.items || [];
	if (!items.length) {
		empty.innerText = "No bug reports submitted yet.";
		empty.style.display = "block";
		results.innerHTML = "";
		return;
	}
	empty.style.display = "none";
	results.innerHTML = items.map((item) => {
		const playerInfo = item.playerId ? `Player ${escapeHtml(item.playerId)}` : "Anonymous";
		const when = item.createdAt ? `Created ${formatRelativeTime(item.createdAt)}` : "Created ‚Äî";
		const seasonLabel = item.seasonId ? `Season ${escapeHtml(item.seasonId)}` : "Season ‚Äî";
		const clientVer = item.clientVersion ? `v${escapeHtml(item.clientVersion)}` : "‚Äî";
		return `
			<div class="card">
				<div class="row" style="justify-content:space-between;">
					<div><strong>${escapeHtml(item.title)}</strong></div>
					<span class="badge">${escapeHtml(item.category || "other")}</span>
				</div>
				<div class="label">${escapeHtml(item.description)}</div>
				<div class="notice-meta" style="margin-top:0.5rem;">
					<span class="muted">${seasonLabel}</span>
					<span class="muted">¬∑</span>
					<span class="muted">${playerInfo}</span>
					<span class="muted">¬∑</span>
					<span class="muted">${when}</span>
					<span class="muted">¬∑</span>
					<span class="muted">Client ${clientVer}</span>
				</div>
			</div>
		`;
	}).join("");
}

async function loadAdminSeasons() {
	if (!currentUser || !currentUser.isAdmin) return;
	if (!adminSeasonList) return;
	try {
		const [seasonRes, economyRes] = await Promise.all([
			apiFetch("/seasons"),
			apiFetch("/admin/economy")
		]);
		const seasonData = await seasonRes.json();
		const economyData = await economyRes.json();
		const seasons = seasonData.seasons || [];
		if (!seasons.length) {
			adminSeasonList.innerHTML = "";
			if (adminSeasonEmpty) adminSeasonEmpty.style.display = "block";
			if (adminSeasonStatus) adminSeasonStatus.style.display = "none";
			if (adminSeasonDetail) adminSeasonDetail.style.display = "none";
			return;
		}
		if (adminSeasonEmpty) adminSeasonEmpty.style.display = "none";
		adminSeasonList.innerHTML = seasons.map((season) => {
			const ended = seasonStatusValue(season) === "ended";
			const status = seasonStatusLabelAdmin(season);
			const badgeClass = ended ? "badge warn" : "badge accent";
			const marketPressure = formatPressureValue(economyData.marketPressure, ended);
			const emissionTarget = ended
				? "Frozen"
				: (economyData.dailyEmissionTarget ?? "--");
			return `
				<div class="card notice clickable" data-season-id="${season.seasonId}">
					<div class="row" style="justify-content:space-between; align-items:center;">
						<div>
							<div class="label">Season ID</div>
							<div class="stat-value">${season.seasonId}</div>
						</div>
						<span class="${badgeClass}">${status}</span>
					</div>
					<div class="label" style="margin-top:0.5rem;">Day ${formatSeasonDay(season)}</div>
					<div class="label">Base price ${formatMicrocoinsToCoinsDisplay(economyData.baseStarPrice)} ¬∑ Effective ${formatMicrocoinsToCoinsDisplay(season.currentStarPrice)}</div>
					<div class="label">Market pressure ${marketPressure}</div>
					<div class="label">Emission target ${emissionTarget}</div>
				</div>
			`;
		}).join("");

		const first = seasons[0];
		
		// Populate Season Status block
		if (first && adminSeasonStatus) {
			const ended = seasonStatusValue(first) === "ended";
			const secondsRemaining = first.secondsRemaining || 0;
			const endTime = new Date(Date.now() + (secondsRemaining * 1000));
			const endTimeFormatted = endTime.toLocaleString();
			
			if (adminSeasonStatusId) adminSeasonStatusId.innerText = formatSeasonDisplayNumber(first);
			if (adminSeasonStatusValue) adminSeasonStatusValue.innerText = ended ? "ENDED" : "ACTIVE";
			if (adminSeasonStatusDay) adminSeasonStatusDay.innerText = formatSeasonDay(first);
			if (adminSeasonStatusEnds) adminSeasonStatusEnds.innerText = endTimeFormatted;
			
			adminSeasonStatus.style.display = "block";
			
			// Show status message if within 24 hours
			if (adminSeasonStatusMessage) {
				adminSeasonStatusMessage.innerText = "";
				const hoursRemaining = secondsRemaining / 3600;
				if (hoursRemaining > 0 && hoursRemaining <= 24) {
					adminSeasonStatusMessage.innerHTML = "‚ö† Season nearing completion<br>This Alpha season will automatically roll over.<br>No admin action required.";
				}
			}
		}
		
		if (adminSeasonDetail && adminSeasonMetrics && first) {
			const ended = seasonStatusValue(first) === "ended";
			const marketPressure = formatPressureValue(economyData.marketPressure, ended);
			const emissionTarget = ended
				? "Frozen"
				: (economyData.dailyEmissionTarget ?? "--");
			adminSeasonDetail.style.display = "block";
			adminSeasonMetrics.innerHTML = `
				<div class="admin-metric"><div class="label">Season ID</div><div class="stat-value">${first.seasonId}</div></div>
				<div class="admin-metric"><div class="label">Day</div><div class="stat-value">${formatSeasonDay(first)}</div></div>
				<div class="admin-metric"><div class="label">Status</div><div class="stat-value">${seasonStatusLabelAdmin(first)}</div></div>
				<div class="admin-metric"><div class="label">Base price</div><div class="stat-value">${formatMicrocoinsToCoinsDisplay(economyData.baseStarPrice)}</div></div>
				<div class="admin-metric"><div class="label">Effective price</div><div class="stat-value">${formatMicrocoinsToCoinsDisplay(first.currentStarPrice)}</div></div>
				<div class="admin-metric"><div class="label">Market pressure</div><div class="stat-value">${marketPressure}</div></div>
				<div class="admin-metric"><div class="label">Emission state</div><div class="stat-value">${emissionTarget}</div></div>
				<div class="admin-metric"><div class="label">Coins in circulation</div><div class="stat-value">${formatCoinsInCirculationForSeason(first)}</div></div>
			`;
			updateAdminControlVisibility(first);
		}
	} catch (e) {
		if (adminSeasonList) adminSeasonList.innerHTML = "";
		if (adminSeasonEmpty) adminSeasonEmpty.style.display = "block";
		if (adminSeasonStatus) adminSeasonStatus.style.display = "none";
		if (adminSeasonDetail) adminSeasonDetail.style.display = "none";
	}
}

function summarizeSeverity(items) {
	const totals = { low: 0, elevated: 0, critical: 0 };
	items.forEach((item) => {
		if (item.severity >= 3) {
			totals.critical += 1;
		} else if (item.severity >= 2) {
			totals.elevated += 1;
		} else {
			totals.low += 1;
		}
	});
	return totals;
}

function summarizePatterns(items) {
	const counts = {};
	items.forEach((item) => {
		const key = item.eventType || "unknown";
		counts[key] = (counts[key] || 0) + 1;
	});
	return Object.entries(counts)
		.sort((a, b) => b[1] - a[1])
		.slice(0, 5);
}

async function loadAdminAbuseEvents() {
	if (!currentUser || !currentUser.isAdmin) return;
	const abuseStream = document.getElementById("admin-abuse-stream");
	const abuseSeverity = document.getElementById("admin-abuse-severity");
	const abusePatterns = document.getElementById("admin-abuse-patterns");
	try {
		const res = await apiFetch("/admin/abuse-events");
		const data = await res.json();
		if (!data.ok) {
			if (abuseStream) abuseStream.innerText = "Unable to load abuse events.";
			return;
		}
		const items = data.items || [];
		if (abuseStream) {
			if (!items.length) {
				abuseStream.innerText = "No abuse events recorded.";
			} else {
				abuseStream.innerHTML = items.slice(0, 10).map((item) => {
					const when = item.createdAt ? formatRelativeTime(item.createdAt) : "";
					const season = item.seasonId ? `Season ${escapeHtml(item.seasonId)}` : "";
					return `
						<div class="notice">
							<div class="notice-content">
								<div><strong>${escapeHtml(item.eventType || "event")}</strong> ¬∑ Severity ${item.severity}</div>
								<div class="notice-meta">
									<span class="badge subtle">${season || "Unscoped"}</span>
									<span class="muted">${when}</span>
								</div>
							</div>
						</div>
					`;
				}).join("");
			}
		}
		if (abuseSeverity) {
			const totals = summarizeSeverity(items);
			abuseSeverity.innerText = `${totals.low} low ¬∑ ${totals.elevated} elevated ¬∑ ${totals.critical} critical`;
		}
		if (abusePatterns) {
			const patterns = summarizePatterns(items);
			if (!patterns.length) {
				abusePatterns.innerText = "No patterns detected.";
			} else {
				abusePatterns.innerHTML = patterns.map(([key, count]) => `
					<div class="notice">
						<div class="notice-content">
							<div><strong>${escapeHtml(key)}</strong></div>
							<div class="notice-meta"><span class="badge subtle">${count} signals</span></div>
						</div>
					</div>
				`).join("");
			}
		}
	} catch (e) {
		if (abuseStream) abuseStream.innerText = "Unable to load abuse events.";
	}
}

async function loadAdminOverview() {
	if (!currentUser || !currentUser.isAdmin) return;
	try {
		const res = await apiFetch("/admin/overview");
		const data = await res.json();
		if (!data.ok) {
			setIndicator(adminIndicatorServer, "Server Status: Degraded", "danger");
			return;
		}
		const economy = economyState(data.marketPressure);
		const abuse = abuseSignalState(data.activeAbuseFlags || 0, data.abuseEventsLastHour || 0, data.abuseSevereLastHour || 0);
		setIndicator(adminIndicatorServer, "Server Status: OK", "ok");
		setIndicator(adminIndicatorEconomy, `Economy State: ${economy.label}`, economy.level);
		setIndicator(adminIndicatorAbuse, `Abuse Signals: ${abuse.label}`, abuse.level);
		if (adminOverviewSeasons) adminOverviewSeasons.innerText = `${data.activeSeasons}`;
		if (adminOverviewCoins) adminOverviewCoins.innerText = `${data.coinsEmittedLastHour}`;
		if (adminOverviewStars) adminOverviewStars.innerText = `${data.starsPurchasedLastHour}`;
		if (adminOverviewPressure) {
			const ratio = typeof data.marketPressureRatio === "number" && isFinite(data.marketPressureRatio)
				? `${data.marketPressureRatio.toFixed(2)}x`
				: "--";
			const pressure = typeof data.marketPressure === "number" && isFinite(data.marketPressure)
				? `${data.marketPressure.toFixed(2)}x`
				: "--";
			adminOverviewPressure.innerText = `${pressure} ¬∑ ${ratio}`;
		}
		if (adminOverviewThrottles) adminOverviewThrottles.innerText = `${data.activeThrottles}`;
		if (adminOverviewFlags) adminOverviewFlags.innerText = `${data.activeAbuseFlags}`;
	} catch (e) {
		setIndicator(adminIndicatorServer, "Server Status: Degraded", "danger");
	}
}

function startAdminLoops() {
	if (adminOverviewTimer) return;
	loadAdminOverview();
	loadAdminSeasons();
	loadAdminAbuseEvents();
	loadAdminAntiCheat();
	adminOverviewTimer = setInterval(loadAdminOverview, 10000);
	adminAbuseTimer = setInterval(loadAdminAbuseEvents, 12000);
	adminAntiCheatTimer = setInterval(loadAdminAntiCheat, 15000);
}

function stopAdminLoops() {
	if (adminOverviewTimer) clearInterval(adminOverviewTimer);
	adminOverviewTimer = null;
	if (adminAbuseTimer) clearInterval(adminAbuseTimer);
	adminAbuseTimer = null;
	if (adminAntiCheatTimer) clearInterval(adminAntiCheatTimer);
	adminAntiCheatTimer = null;
}

function getRouteInfo() {
	const hash = location.hash.replace("#", "");
	if (!hash || hash === "/") {
		return { routeKey: "home", query: new URLSearchParams() };
	}
	const trimmed = hash.startsWith("/") ? hash.slice(1) : hash;
	const parts = trimmed.split("?");
	const routeKey = viewMap[parts[0]] ? parts[0] : "home";
	const query = new URLSearchParams(parts[1] || "");
	return { routeKey, query };
}

function isAdminRoute() {
	return getRouteInfo().routeKey === "admin";
}

async function route() {
	const { routeKey, query } = getRouteInfo();
	setDebugStatus(`Routing: ${routeKey || "home"}`);
	try {
		await loadAuth();
	} catch (e) {
		setDebugStatus("Routing: auth probe failed");
	}
	initCollapsibleCards();
	stopAdminLoops();
	if (routeKey === "signup" && currentUser) {
		location.hash = "#/home";
		return;
	}
	setView(viewMap[routeKey]);
	setDebugStatus(`View: ${viewMap[routeKey] || "missing"}`);
	if (currentUser && !document.hidden) {
		startActiveLoops();
	} else {
		stopActiveLoops();
	}
	if (routeKey === "home") {
		if (!homeInitialized) initHome();
		await refreshPlayer();
		return;
	}
	if (routeKey === "signup") {
		if (!signupInitialized) initSignup();
		return;
	}
	if (routeKey === "reset") {
		if (!resetInitialized) initReset();
		const token = query.get("token") || "";
		if (token) {
			document.getElementById("reset-token").value = token;
		}
		return;
	}
	if (routeKey === "admin/initialize") {
		if (!adminBootstrapInitialized) initAdminInitialize();
		await refreshAdminInitializeView();
		return;
	}
	if (routeKey === "moderator") {
		if (!moderatorInitialized) initModerator();
		await refreshModeratorView();
		return;
	}
	if (routeKey === "admin") {
		if (!adminInitialized) initAdmin();
		refreshAdminView();
		startAdminLoops();
		return;
	}
	if (routeKey === "leaderboard") {
		if (!leaderboardInitialized) initLeaderboard();
		await loadLeaderboard();
		return;
	}
}

function initHome() {
	homeInitialized = true;
	document.getElementById("login-btn").addEventListener("click", async () => {
		// Guard: don't allow login before bootstrap is complete
		if (!bootstrapGateResolved) {
			setToast("System is still initializing. Please wait.", "error");
			return;
		}
		
		const username = document.getElementById("username").value;
		const password = document.getElementById("password").value;
		if (!username || !password) {
			setToast("Enter username and password.", "error");
			return;
		}
		setToast("Logging in...", "success");
		try {
			const res = await apiFetch("/auth/login", {
				method: "POST",
				body: JSON.stringify({ username, password })
			});
			let data = null;
			try {
				data = await res.json();
			} catch (e) {
				setToast("Login failed (invalid response)", "error");
				return;
			}
			if (!data.ok) {
				setToast(data.error || "Login failed", "error");
				return;
			}
			await loadAuth();
			if (!currentUser) {
				setToast("Login failed (session not established)", "error");
				return;
			}
			await refreshPlayer();
			await loadSeasons();
			setToast("Logged in.", "success");
			if (!document.hidden) {
				startActiveLoops();
			}
			track("login", {});
		} catch (e) {
			setToast("Login failed (network error)", "error");
		}
	});

	logoutBtn.addEventListener("click", async () => {
		await apiFetch("/auth/logout", { method: "POST" });
		currentUser = null;
		stopActiveLoops();
		await loadAuth();
	});

	profileSave.addEventListener("click", async () => {
		const displayName = profileDisplay.value;
		const email = profileEmail.value;
		const res = await apiFetch("/profile", {
			method: "POST",
			body: JSON.stringify({
				displayName,
				email,
				bio: profileBio.value,
				pronouns: profilePronouns.value,
				location: profileLocation.value,
				website: profileWebsite.value,
				avatarUrl: profileAvatar.value
			})
		});
		const data = await res.json();
		if (!data.ok) {
			setToast(data.error || "Update failed", "error");
			return;
		}
		authStatus.innerText = `Logged in as ${data.displayName}`;
		if (profileAvatar.value.trim()) {
			profileAvatarImg.src = profileAvatar.value.trim();
		}
		setToast("Profile updated.", "success");
	});

	document.getElementById("claim-daily").addEventListener("click", async () => {
		if (seasonStatusValue(currentSeasonSnapshot) === "ended") {
			actionsStatus.innerText = "Season ended. Read-only.";
			setToast(actionsStatus.innerText, "error");
			return;
		}
		const res = await apiFetch("/claim-daily", { method: "POST", body: JSON.stringify({}) });
		const data = await res.json();
		if (!data.ok) {
			actionsStatus.innerText = data.error || "Claim failed";
			setToast(actionsStatus.innerText, "error");
			return;
		}
		actionsStatus.innerText = `Daily claim: +${data.reward} coins`;
		setToast("Daily claim received.", "success");
		await refreshPlayer();
	});

	document.getElementById("claim-activity").addEventListener("click", async () => {
		if (seasonStatusValue(currentSeasonSnapshot) === "ended") {
			actionsStatus.innerText = "Season ended. Read-only.";
			setToast(actionsStatus.innerText, "error");
			return;
		}
		const res = await apiFetch("/claim-activity", { method: "POST", body: JSON.stringify({}) });
		const data = await res.json();
		if (!data.ok) {
			actionsStatus.innerText = data.error || "Claim failed";
			setToast(actionsStatus.innerText, "error");
			return;
		}
		actionsStatus.innerText = `Activity claim: +${data.reward} coins`;
		setToast("Activity claim received.", "success");
		await refreshPlayer();
	});

	document.getElementById("dismiss-hint").addEventListener("click", () => {
		localStorage.setItem("dismissedHint", "true");
		onboarding.style.display = "none";
	});

	if (localStorage.getItem("dismissedHint") !== "true") {
		onboarding.style.display = "block";
	}

	document.addEventListener("visibilitychange", handleVisibility);
	handleVisibility();
}

function initSignup() {
	signupInitialized = true;
	document.getElementById("signup-btn").addEventListener("click", async () => {
		const username = document.getElementById("signup-username").value;
		const password = document.getElementById("signup-password").value;
		const displayName = document.getElementById("signup-display-name").value;
		const email = document.getElementById("signup-email").value;
		const res = await apiFetch("/auth/signup", {
			method: "POST",
			body: JSON.stringify({ username, password, displayName, email })
		});
		const data = await res.json();
		const toast = document.getElementById("signup-toast");
		if (!data.ok) {
			toast.innerText = data.error || "Signup failed";
			toast.style.display = "block";
			return;
		}
		location.hash = "#/home";
	});
}

function initReset() {
	resetInitialized = true;
	document.getElementById("reset-request-btn").addEventListener("click", async () => {
		const identifier = document.getElementById("reset-identifier").value.trim();
		const res = await apiFetch("/auth/request-reset", {
			method: "POST",
			body: JSON.stringify({ identifier })
		});
		const data = await res.json();
		const status = document.getElementById("reset-request-status");
		status.innerText = data.ok ? "If the account exists, a reset email was sent." : (data.error || "Request failed");
	});

	document.getElementById("reset-confirm-btn").addEventListener("click", async () => {
		const token = document.getElementById("reset-token").value.trim();
		const newPassword = document.getElementById("reset-new-password").value;
		const res = await apiFetch("/auth/reset-password", {
			method: "POST",
			body: JSON.stringify({ token, newPassword })
		});
		const data = await res.json();
		const status = document.getElementById("reset-confirm-status");
		if (!data.ok) {
			status.innerText = data.error || "Reset failed";
			return;
		}
		status.innerText = "Password updated. You can log in now.";
		location.hash = "#/home";
	});
}

function setAdminClaimStatus(message, isError) {
	if (!adminClaimStatus) return;
	adminClaimStatus.innerText = message || "";
	adminClaimStatus.style.color = isError ? "#fecaca" : "";
}

function updateAdminClaimRotation(secondsRemaining) {
	if (!adminClaimRotation) return;
	if (typeof secondsRemaining !== "number" || !isFinite(secondsRemaining)) {
		adminClaimRotation.innerText = "";
		return;
	}
	adminClaimRotation.innerText = secondsRemaining > 0
		? `Code rotates in ${secondsRemaining}s.`
		: "Code rotates soon.";
}

async function loadAdminBootstrapStatus() {
	const result = await apiFetchJson("/admin/bootstrap/status", {}, 2500);
	const data = result.data;
	if (!data || typeof data.adminLocked !== "boolean") {
		return null;
	}
	return data;
}

async function refreshAdminInitializeView() {
	if (!adminInitCard) return;
	adminInitCard.style.display = "none";
	setAdminClaimStatus("Checking admin lock status...", false);
	const status = await loadAdminBootstrapStatus();
	if (!status) {
		setAdminClaimStatus("Unable to load bootstrap status.", true);
		return;
	}
	if (!status.adminLocked) {
		location.hash = "#/admin";
		return;
	}
	adminInitCard.style.display = "block";
	setAdminClaimStatus("", false);
	updateAdminClaimRotation(status.windowSecondsRemaining);
}

function initAdminInitialize() {
	adminBootstrapInitialized = true;
	if (adminClaimSubmit) {
		adminClaimSubmit.addEventListener("click", async () => {
			if (!adminClaimCode || !adminClaimPassword || !adminClaimConfirm) return;
			const code = adminClaimCode.value.trim();
			const newPassword = adminClaimPassword.value;
			const confirmPassword = adminClaimConfirm.value;
			if (!code) {
				setAdminClaimStatus("Enter the owner claim code.", true);
				return;
			}
			if (!newPassword || newPassword.length < 8) {
				setAdminClaimStatus("Password must be at least 8 characters.", true);
				return;
			}
			if (newPassword !== confirmPassword) {
				setAdminClaimStatus("Passwords do not match.", true);
				return;
			}

			setAdminClaimStatus("Submitting claim...", false);
			try {
				const res = await apiFetch("/admin/bootstrap/claim", {
					method: "POST",
					body: JSON.stringify({ code, newPassword })
				});
				const data = await res.json();
				if (!data.ok) {
					const message = data.error || "Claim failed.";
					setAdminClaimStatus(message, true);
					return;
				}
				setAdminClaimStatus("Admin unlocked. Redirecting to login...", false);
				setTimeout(() => {
					location.hash = "#/home";
				}, 600);
			} catch (e) {
				setAdminClaimStatus("Claim failed (network error).", true);
			}
		});
	}
}

function initModerator() {
	moderatorInitialized = true;
	const profileCard = document.getElementById("moderator-profile");
	const adminActionsCard = document.getElementById("mod-admin-actions");
	const statusView = document.getElementById("mod-status-view");
	const adminStatus = document.getElementById("mod-admin-status");
	let loadedUsername = "";

	document.getElementById("mod-load-view").addEventListener("click", async () => {
		const username = document.getElementById("mod-username-view").value.trim();
		if (!username) {
			statusView.innerText = "Enter a username.";
			return;
		}
		const res = await apiFetch(`/moderator/profile?username=${encodeURIComponent(username)}`);
		const data = await res.json();
		if (!data.ok) {
			document.getElementById("mod-status-view").innerText = data.error || "Load failed.";
			return;
		}
		loadedUsername = data.username || username;
		document.getElementById("mod-display-name-view").value = data.displayName || "";
		document.getElementById("mod-email-view").value = data.email || "";
		document.getElementById("mod-pronouns-view").value = data.pronouns || "";
		document.getElementById("mod-location-view").value = data.location || "";
		document.getElementById("mod-website-view").value = data.website || "";
		document.getElementById("mod-avatar-view").value = data.avatarUrl || "";
		document.getElementById("mod-bio-view").value = data.bio || "";
		const roleLabel = data.role ? `Role: ${data.role}` : "";
		const frozenLabel = data.frozen ? " ¬∑ Frozen" : "";
		document.getElementById("mod-status-view").innerText = roleLabel ? `Profile loaded. ${roleLabel}${frozenLabel}` : "Profile loaded.";
		if (profileCard) profileCard.style.display = "block";
		if (adminActionsCard) adminActionsCard.style.display = (currentUser && currentUser.isAdmin) ? "block" : "none";
		if (adminStatus) adminStatus.innerText = "";
		const isSelf = currentUser && currentUser.username && loadedUsername
			? currentUser.username.toLowerCase() === loadedUsername.toLowerCase()
			: false;
		const freezeBtn = document.getElementById("mod-freeze");
		const unfreezeBtn = document.getElementById("mod-unfreeze");
		const deleteBtn = document.getElementById("mod-delete");
		if (freezeBtn) freezeBtn.disabled = isSelf;
		if (unfreezeBtn) unfreezeBtn.disabled = isSelf;
		if (deleteBtn) deleteBtn.disabled = isSelf;
	});

	document.getElementById("mod-save-view").addEventListener("click", async () => {
		const username = document.getElementById("mod-username-view").value.trim();
		if (!username) {
			statusView.innerText = "Load a profile first.";
			return;
		}
		const displayName = document.getElementById("mod-display-name-view").value.trim();
		const email = document.getElementById("mod-email-view").value.trim();
		const pronouns = document.getElementById("mod-pronouns-view").value.trim();
		const location = document.getElementById("mod-location-view").value.trim();
		const website = document.getElementById("mod-website-view").value.trim();
		const avatarUrl = document.getElementById("mod-avatar-view").value.trim();
		const bio = document.getElementById("mod-bio-view").value.trim();
		const res = await apiFetch("/moderator/profile", {
			method: "POST",
			body: JSON.stringify({ username, displayName, email, pronouns, location, website, avatarUrl, bio })
		});
		const data = await res.json();
		document.getElementById("mod-status-view").innerText = data.ok ? "Profile updated." : (data.error || "Update failed.");
	});

	document.getElementById("mod-freeze").addEventListener("click", async () => {
		if (!currentUser || !currentUser.isAdmin) {
			adminStatus.innerText = "Admin access required.";
			return;
		}
		const username = document.getElementById("mod-username-view").value.trim();
		if (!username) {
			adminStatus.innerText = "Load a profile first.";
			return;
		}
		if (!confirm(`Freeze account ${username}?`)) {
			return;
		}
		const res = await apiFetch("/admin/profile-actions", {
			method: "POST",
			body: JSON.stringify({ username, action: "freeze" })
		});
		const data = await res.json();
		adminStatus.innerText = data.ok ? "Account frozen." : (data.error || "Freeze failed.");
	});

	document.getElementById("mod-unfreeze").addEventListener("click", async () => {
		if (!currentUser || !currentUser.isAdmin) {
			adminStatus.innerText = "Admin access required.";
			return;
		}
		const username = document.getElementById("mod-username-view").value.trim();
		if (!username) {
			adminStatus.innerText = "Load a profile first.";
			return;
		}
		if (!confirm(`Unfreeze account ${username}?`)) {
			return;
		}
		const res = await apiFetch("/admin/profile-actions", {
			method: "POST",
			body: JSON.stringify({ username, action: "unfreeze" })
		});
		const data = await res.json();
		adminStatus.innerText = data.ok ? "Account unfrozen." : (data.error || "Unfreeze failed.");
	});

	document.getElementById("mod-delete").addEventListener("click", async () => {
		if (!currentUser || !currentUser.isAdmin) {
			adminStatus.innerText = "Admin access required.";
			return;
		}
		const username = document.getElementById("mod-username-view").value.trim();
		if (!username) {
			adminStatus.innerText = "Load a profile first.";
			return;
		}
		if (!confirm(`Delete account ${username}? This cannot be undone.`)) {
			return;
		}
		const confirmText = prompt("Type DELETE to confirm account deletion:");
		if (confirmText !== "DELETE") {
			adminStatus.innerText = "Deletion canceled.";
			return;
		}
		const res = await apiFetch("/admin/profile-actions", {
			method: "POST",
			body: JSON.stringify({ username, action: "delete" })
		});
		const data = await res.json();
		adminStatus.innerText = data.ok ? "Account deleted." : (data.error || "Delete failed.");
	});

}

async function refreshModeratorView() {
	const res = await apiFetch("/auth/me");
	const data = await res.json();
	if (!data.ok || (!data.isModerator && !data.isAdmin)) {
		document.getElementById("mod-no-access").style.display = "block";
		document.getElementById("moderator-content").style.display = "none";
		document.getElementById("moderator-profile").style.display = "none";
		document.getElementById("mod-admin-actions").style.display = "none";
		return false;
	}
	document.getElementById("mod-no-access").style.display = "none";
	document.getElementById("moderator-content").style.display = "block";
	document.getElementById("moderator-profile").style.display = "none";
	document.getElementById("mod-admin-actions").style.display = "none";
	return true;
}

window.addEventListener("error", (event) => {
	setToast(`Error: ${event.message}`, "error");
	setDebugStatus(`Error: ${event.message}`);
});

window.addEventListener("unhandledrejection", (event) => {
	setToast("Error: unexpected failure", "error");
	setDebugStatus("Error: unhandled rejection");
});

window.addEventListener("hashchange", () => {
	route().catch((err) => {
		const message = err && err.message ? err.message : "route failed";
		setToast(`Error: ${message}`, "error");
	});
});

route().catch((err) => {
	const message = err && err.message ? err.message : "route failed";
	setToast(`Error: ${message}`, "error");
	updateDebugVisibility();
});

// Bug Report Handler
function initBugReporting() {
	const reportLink = document.getElementById("report-bug-link");
	const bugView = document.getElementById("view-bug-report");
	const bugTitle = document.getElementById("bug-title");
	const bugDescription = document.getElementById("bug-description");
	const bugCategory = document.getElementById("bug-category");
	const bugClientVersion = document.getElementById("bug-client-version");
	const bugSubmit = document.getElementById("bug-submit");
	const bugStatus = document.getElementById("bug-status");
	const bugCancel = document.getElementById("bug-cancel");

	if (!reportLink || !bugView) return;

	reportLink.addEventListener("click", (event) => {
		event.preventDefault();
		setView("view-bug-report");
		if (bugTitle) bugTitle.value = "";
		if (bugDescription) bugDescription.value = "";
		if (bugCategory) bugCategory.value = "other";
		if (bugClientVersion) bugClientVersion.value = "";
		if (bugStatus) bugStatus.innerText = "";
	});

	if (bugCancel) {
		bugCancel.addEventListener("click", () => {
			location.hash = "#/home";
		});
	}

	if (bugSubmit) {
		bugSubmit.addEventListener("click", async () => {
			const title = bugTitle?.value?.trim() || "";
			const description = bugDescription?.value?.trim() || "";
			const category = bugCategory?.value?.trim() || "other";
			const clientVersion = bugClientVersion?.value?.trim() || "";

			if (!title || !description) {
				if (bugStatus) bugStatus.innerText = "Title and description are required.";
				bugStatus.style.color = "#fecaca";
				return;
			}

			if (bugStatus) bugStatus.innerText = "Submitting...";
			bugStatus.style.color = "";

			try {
				const res = await apiFetch("/bugs/report", {
					method: "POST",
					body: JSON.stringify({
						title,
						description,
						category,
						clientVersion
					})
				});

				const data = await res.json();
				if (!data.ok) {
					if (bugStatus) bugStatus.innerText = data.error || "Submission failed.";
					bugStatus.style.color = "#fecaca";
					return;
				}

				// Clear form on success
				if (bugTitle) bugTitle.value = "";
				if (bugDescription) bugDescription.value = "";
				if (bugCategory) bugCategory.value = "other";
				if (bugClientVersion) bugClientVersion.value = "";

				if (bugStatus) {
					bugStatus.innerText = "Thank you for your report. Redirecting...";
					bugStatus.style.color = "#bbf7d0";
				}

				setTimeout(() => {
					location.hash = "#/home";
				}, 800);
			} catch (e) {
				if (bugStatus) {
					bugStatus.innerText = "Submission failed (network error).";
					bugStatus.style.color = "#fecaca";
				}
			}
		});
	}
}

initBugReporting();
	</script>
</body>
</html>

