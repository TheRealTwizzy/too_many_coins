<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8" />
	<meta name="viewport" content="width=device-width, initial-scale=1" />
	<title>Too Many Coins</title>
	<style>
	:root {
		color-scheme: dark;
		--bg: #0b0f1d;
		--panel: #141a2e;
		--panel-strong: #1a2140;
		--border: #2a2f55;
		--text: #eaeaf0;
		--muted: #9aa3c4;
		--accent: #3b82f6;
		--success: #22c55e;
		--warning: #f59e0b;
		--danger: #ef4444;
	}
	body {
		font-family: "Inter", system-ui, sans-serif;
		background: radial-gradient(circle at top, #151c35 0%, #0b0f1d 45%, #060814 100%);
		color: var(--text);
		margin: 0;
		min-height: 100vh;
		display: flex;
		flex-direction: column;
	}
	header {
		position: sticky;
		top: 0;
		z-index: 15;
		display: flex;
		align-items: center;
		justify-content: space-between;
		gap: 1.5rem;
		padding: 1.25rem 2rem;
		background: rgba(8, 12, 26, 0.92);
		backdrop-filter: blur(12px);
		border-bottom: 1px solid var(--border);
	}
	main {
		padding: 2rem;
		max-width: 1200px;
		width: 100%;
		margin: 0 auto;
		box-sizing: border-box;
	}
	.app-title {
		display: flex;
		align-items: center;
		gap: 1rem;
	}
	.app-mark {
		width: 42px;
		height: 42px;
		border-radius: 14px;
		background: linear-gradient(135deg, #3b82f6, #6366f1);
		display: grid;
		place-items: center;
		font-weight: 700;
		color: white;
		box-shadow: 0 12px 24px rgba(59, 130, 246, 0.35);
	}
	.app-actions {
		display: flex;
		flex-direction: column;
		align-items: flex-end;
		gap: 0.65rem;
	}
	.nav-links a {
		color: #c5cae9;
		text-decoration: none;
		margin-left: 0.75rem;
		font-size: 0.85rem;
	}
	.live-status {
		display: inline-flex;
		align-items: center;
		gap: 0.4rem;
		font-size: 0.75rem;
		padding: 0.25rem 0.5rem;
		border-radius: 999px;
		border: 1px solid rgba(34, 197, 94, 0.5);
		color: #bbf7d0;
		background: rgba(34, 197, 94, 0.12);
	}
	.live-status::before {
		content: "";
		width: 6px;
		height: 6px;
		border-radius: 999px;
		background: #22c55e;
		box-shadow: 0 0 8px rgba(34, 197, 94, 0.8);
	}
	.live-status.offline {
		border-color: rgba(239, 68, 68, 0.5);
		color: #fecaca;
		background: rgba(239, 68, 68, 0.12);
	}
	.live-status.offline::before {
		background: #ef4444;
		box-shadow: 0 0 8px rgba(239, 68, 68, 0.8);
	}
	.live-status.reconnecting {
		border-color: rgba(245, 158, 11, 0.5);
		color: #fde68a;
		background: rgba(245, 158, 11, 0.12);
	}
	.live-status.reconnecting::before {
		background: #f59e0b;
		box-shadow: 0 0 8px rgba(245, 158, 11, 0.8);
	}
	.badge {
		font-size: 0.75rem;
		padding: 0.25rem 0.5rem;
		border-radius: 999px;
		background: #1f2544;
		border: 1px solid #2a2f55;
	}
	.badge.accent {
		background: rgba(59, 130, 246, 0.15);
		border-color: rgba(59, 130, 246, 0.5);
		color: #93c5fd;
	}
	.badge.bot {
		background: rgba(248, 113, 113, 0.15);
		border-color: rgba(248, 113, 113, 0.5);
		color: #fecaca;
	}
	.card {
		border: 1px solid var(--border);
		padding: 1.25rem;
		margin-bottom: 1rem;
		border-radius: 16px;
		background: var(--panel);
		box-shadow: 0 18px 30px rgba(0, 0, 0, 0.25);
	}
	.card-header {
		display: flex;
		align-items: center;
		justify-content: space-between;
		gap: 1rem;
		margin-bottom: 1rem;
	}
	.hero-card {
		background: linear-gradient(140deg, rgba(59, 130, 246, 0.2), rgba(20, 26, 46, 0.95));
		border-color: rgba(59, 130, 246, 0.5);
	}
	.hero-grid {
		display: grid;
		grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
		gap: 1.5rem;
	}
	.metric-grid {
		display: grid;
		grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
		gap: 0.9rem;
	}
	.metric {
		padding: 0.75rem 0.9rem;
		background: rgba(10, 14, 28, 0.6);
		border-radius: 12px;
		border: 1px solid rgba(42, 47, 85, 0.8);
	}
	.stat-value {
		font-size: 1.1rem;
		font-weight: 600;
	}
	.dashboard-grid {
		display: grid;
		grid-template-columns: minmax(0, 2fr) minmax(0, 1fr);
		gap: 1.5rem;
		align-items: start;
	}
	.dashboard-main {
		display: flex;
		flex-direction: column;
		gap: 1rem;
	}
	.dashboard-side {
		display: flex;
		flex-direction: column;
		gap: 1rem;
	}
	.season-card {
		display: flex;
		flex-direction: column;
		gap: 1rem;
	}
	.season-card-header {
		display: flex;
		align-items: center;
		justify-content: space-between;
		gap: 1rem;
	}
	.season-card-grid {
		display: grid;
		grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
		gap: 0.75rem;
	}
	.season-actions {
		display: flex;
		gap: 0.5rem;
		flex-wrap: wrap;
	}
	.section-stack {
		display: flex;
		flex-direction: column;
		gap: 1rem;
	}
	.section-nav {
		display: flex;
		flex-wrap: wrap;
		gap: 0.75rem;
		font-size: 0.85rem;
	}
	.section-nav a {
		color: #c5cae9;
		text-decoration: none;
	}
	.split-grid {
		display: grid;
		grid-template-columns: repeat(auto-fit, minmax(260px, 1fr));
		gap: 1rem;
	}
	.card-toggle {
		display: flex;
		align-items: center;
		justify-content: space-between;
		gap: 0.75rem;
	}
	.card-toggle .label {
		font-size: 0.9rem;
		color: #c5cae9;
	}
	.card-body {
		margin-top: 0.75rem;
	}
	.card.collapsed .card-body {
		display: none;
	}
	.recommended {
		border-color: #ffd166;
		background: rgba(255, 209, 102, 0.08);
	}
	.label {
		font-size: 0.8rem;
		color: #aaa;
	}
	input, textarea, button {
		background: #0f1220;
		border: 1px solid #2a2f55;
		color: #eaeaf0;
		padding: 0.5rem 0.75rem;
		border-radius: 8px;
	}
	button {
		cursor: pointer;
	}
	button.primary {
		background: #3b82f6;
		border-color: #3b82f6;
	}
	button.danger {
		background: var(--danger);
		border-color: var(--danger);
	}
	.row {
		display: flex;
		align-items: center;
		gap: 0.75rem;
		flex-wrap: wrap;
	}
	.stack {
		display: flex;
		flex-direction: column;
		gap: 0.5rem;
	}
	.toast {
		padding: 0.6rem 0.8rem;
		border-radius: 8px;
		background: #11162b;
		border: 1px solid #2a2f55;
		font-size: 0.85rem;
	}
	.toast.error {
		border-color: #ef4444;
		color: #fecaca;
	}
	.toast.success {
		border-color: #22c55e;
		color: #bbf7d0;
	}
	.muted {
		color: #9aa3c4;
		font-size: 0.8rem;
	}
	.grid {
		display: grid;
		grid-template-columns: repeat(auto-fit, minmax(240px, 1fr));
		gap: 1rem;
	}
	.notice {
		padding: 0.75rem 1rem;
		border-radius: 10px;
		border: 1px solid #2a2f55;
		background: #11162b;
		margin-bottom: 0.5rem;
		display: flex;
		align-items: center;
		justify-content: space-between;
		gap: 1rem;
	}
	.notice.info { border-color: #2a2f55; }
	.notice.warn { border-color: #f59e0b; color: #fde68a; }
	.notice.urgent { border-color: #ef4444; color: #fecaca; }
	.notice button { padding: 0.25rem 0.6rem; }
	.notice.read {
		opacity: 0.55;
		filter: saturate(0.7);
	}
	.notice.unread {
		box-shadow: 0 0 0 1px rgba(59, 130, 246, 0.45), 0 0 18px rgba(59, 130, 246, 0.15);
	}
	.notice.clickable { cursor: pointer; }
	.notification-panel {
		position: fixed;
		right: 1.5rem;
		bottom: 1.5rem;
		width: min(420px, 92vw);
		max-height: 70vh;
		overflow: auto;
		padding: 1rem;
		border-radius: 12px;
		background: #141a2e;
		border: 1px solid #2a2f55;
		box-shadow: 0 20px 40px rgba(0,0,0,0.35);
		z-index: 20;
	}
	.notification-section {
		margin-top: 0.75rem;
	}
	.view { display: none; }
	.view.active { display: block; }
	.footer { margin-top: auto; text-align: center; font-size: 0.8rem; color: #9aa3c4; padding: 1.5rem 0; }
	@media (max-width: 720px) {
		main {
			padding: 1.25rem;
		}
		header {
			flex-direction: column;
			align-items: flex-start;
			gap: 0.75rem;
			padding: 1rem 1.25rem;
		}
		.app-actions {
			align-items: flex-start;
		}
		.nav-links a {
			margin-left: 0;
			margin-right: 0.75rem;
		}
		.dashboard-grid {
			grid-template-columns: 1fr;
		}
		.grid {
			grid-template-columns: 1fr;
		}
		.row {
			flex-direction: column;
			align-items: stretch;
		}
		.row input,
		.row textarea,
		.row select,
		.row button,
		.stack input,
		.stack textarea,
		.stack select,
		.stack button {
			width: 100%;
		}
		.notification-panel {
			right: 0.75rem;
			bottom: 0.75rem;
			width: min(420px, 94vw);
			max-height: 75vh;
		}
		.notice {
			flex-direction: column;
			align-items: flex-start;
		}
		.footer {
			position: static;
		}
	}
	</style>
</head>
<body>
	<header>
		<div class="app-title">
			<div class="app-mark">TC</div>
			<div>
				<h1>Too Many Coins</h1>
				<div class="label">Season command center · server-authoritative economy</div>
			</div>
		</div>
		<div class="app-actions">
			<div class="row">
				<span class="badge">ALPHA 1</span>
				<span id="stat-pill" class="badge accent" style="display:none;"></span>
				<span id="live-status" class="live-status">Live updates</span>
			</div>
			<nav class="nav-links">
				<a href="#/home">Home</a>
				<a href="#/about">About</a>
				<a href="#/playtest">Playtest</a>
				<a href="#/leaderboard">Leaderboard</a>
				<a id="signup-link" href="#/signup">Sign up</a>
				<a id="moderator-link" href="#/moderator" style="display:none;">Moderate</a>
			</nav>
		</div>
	</header>

	<div id="notification-panel" class="notification-panel" style="display:none;">
		<div class="row" style="justify-content:space-between; align-items:center;">
			<div>
				<strong>Notifications</strong>
				<span id="notification-count" class="badge accent" style="display:none; margin-left:0.5rem;"></span>
			</div>
			<button id="notification-hide">Hide</button>
		</div>
		<div class="notification-section">
			<div class="label">Unread</div>
			<div id="notification-unread" class="stack"></div>
		</div>
		<div class="notification-section">
			<div class="label">Read</div>
			<div id="notification-read" class="stack"></div>
		</div>
	</div>

	<main id="app">
		<section id="view-home" class="view active">
			<div class="card hero-card">
				<div class="hero-grid">
					<div>
						<div class="label">Season dashboard</div>
						<h2 style="margin:0.35rem 0 0;">Real-time economy & star pricing</h2>
						<div class="muted">Live season time, emission, and price updates from the server.</div>
					</div>
					<div class="metric-grid">
						<div class="metric">
							<div class="label">Current season</div>
							<div id="hero-season-id" class="stat-value">Season 1</div>
						</div>
						<div class="metric">
							<div class="label">Time remaining</div>
							<div id="hero-season-remaining" class="stat-value">--</div>
						</div>
						<div class="metric">
							<div class="label">Star price</div>
							<div id="hero-star-price" class="stat-value">--</div>
						</div>
						<div class="metric">
							<div class="label">Inflation pressure</div>
							<div id="hero-inflation" class="stat-value">--</div>
						</div>
					</div>
				</div>
			</div>

			<div class="dashboard-grid">
				<div class="dashboard-main">
					<div id="locked-message" class="label"></div>
					<div class="card" id="season-snapshot" style="display:none;">
						<div class="card-header">
							<div>
								<div class="label">Season snapshot</div>
								<div id="season-title" class="stat-value">Season 1</div>
							</div>
							<span id="season-status" class="badge accent">Active</span>
						</div>
						<div class="metric-grid">
							<div class="metric">
								<div class="label">Time remaining</div>
								<div id="season-remaining" class="stat-value">--</div>
							</div>
							<div class="metric">
								<div class="label">Star price</div>
								<div id="season-star-price" class="stat-value">--</div>
							</div>
							<div class="metric">
								<div class="label">Coins in circulation</div>
								<div id="season-coins" class="stat-value">--</div>
							</div>
							<div class="metric">
								<div class="label">Inflation pressure</div>
								<div id="season-emission" class="stat-value">--</div>
							</div>
							<div class="metric">
								<div class="label">Next coin wave</div>
								<div id="season-next-emission" class="stat-value">--</div>
							</div>
						</div>
					</div>
					<div id="seasons" class="grid">Loading season…</div>
				</div>

				<div class="dashboard-side">
					<div class="card" id="auth-card">
						<div id="auth-status" class="label">Checking session…</div>
						<div id="auth-forms" class="stack">
							<div class="row">
								<input id="username" placeholder="Username" />
								<input id="password" type="password" placeholder="Password" />
							</div>
							<div class="row">
								<button class="primary" id="login-btn" type="button">Log in</button>
								<a class="muted" href="#/signup">Create account</a>
							</div>
							<div class="row">
								<a class="muted" href="#/reset">Forgot password?</a>
							</div>
							<div class="muted">Alpha accounts are local to this test.</div>
						</div>
						<button id="logout-btn" style="display:none;">Log out</button>
					</div>

					<div id="toast" class="toast" style="display:none;"></div>

					<div class="grid" id="player-panels" style="display:none;">
						<div class="card" id="profile-card">
							<div class="card-toggle">
								<div class="label">User panel</div>
							</div>
							<div class="card-body">
								<div class="row">
									<img id="profile-avatar-img" alt="Avatar" style="width:64px; height:64px; border-radius:12px; object-fit:cover; border:1px solid #2a2f55;" />
									<div>
										<div id="profile-name"></div>
										<div id="profile-role" class="label"></div>
										<div id="profile-coins" class="label"></div>
										<div id="profile-stars" class="label"></div>
									</div>
								</div>
								<input id="profile-display" placeholder="Display name" />
								<input id="profile-pronouns" placeholder="Pronouns" />
								<input id="profile-location" placeholder="Location" />
								<input id="profile-website" placeholder="Website" />
								<input id="profile-avatar" placeholder="Avatar URL" />
								<textarea id="profile-bio" rows="3" placeholder="Bio"></textarea>
								<input id="profile-email" placeholder="Email (for password reset)" />
								<button id="profile-save">Save</button>
							</div>
						</div>
					</div>

					<div class="card" id="onboarding" style="display:none;">
						<div class="label">Quick start</div>
						<div>Play the current season. Earn coins over time. Spend them on stars.</div>
						<button id="dismiss-hint">Got it</button>
					</div>

					<div class="card" id="actions-card" style="display:none;">
						<div class="label">Quick actions</div>
						<div class="row">
							<button id="claim-daily" class="primary">Daily claim</button>
							<button id="claim-activity">Activity claim</button>
						</div>
						<div id="actions-status" class="muted"></div>
					</div>

					<div class="card" id="whitelist-request-card" style="display:none;">
						<div class="label">IP whitelist request</div>
						<div class="row">
							<input id="whitelist-reason" placeholder="Reason (optional)" />
							<button id="whitelist-request-btn" class="primary">Request approval</button>
						</div>
						<div id="whitelist-request-status" class="muted"></div>
					</div>
				</div>
			</div>
		</section>

		<section id="view-about" class="view">
			<div class="section-stack">
				<div class="card hero-card">
					<div class="card-header">
						<div>
							<div class="label">About Too Many Coins</div>
							<h2 style="margin:0.35rem 0 0;">A server-authoritative economy built on scarcity.</h2>
							<div class="muted">Coins inflate, stars stay scarce, and every purchase is priced on the server.</div>
						</div>
						<div class="section-nav">
							<a href="#/home">Back to home</a>
							<a href="#/playtest">Playtest notes</a>
						</div>
					</div>
				</div>

				<div class="split-grid">
					<div class="card">
						<div class="label">Core loop</div>
						<ul class="muted" style="margin:0.5rem 0 0; padding-left:1.2rem;">
							<li>Earn coins through limited faucets.</li>
							<li>Buy stars as the season score.</li>
							<li>Prices rise as time passes and demand grows.</li>
						</ul>
					</div>
					<div class="card">
						<div class="label">Design ideals</div>
						<ul class="muted" style="margin:0.5rem 0 0; padding-left:1.2rem;">
							<li>Simple, transparent, and fair.</li>
							<li>Server authority for all economy logic.</li>
							<li>Late-season scarcity stays meaningful.</li>
						</ul>
					</div>
				</div>
			</div>
		</section>

		<section id="view-playtest" class="view">
			<div class="section-stack">
				<div class="card hero-card">
					<div class="card-header">
						<div>
							<div class="label">Playtest focus</div>
							<h2 style="margin:0.35rem 0 0;">Verify pacing, clarity, and late-season pressure.</h2>
							<div class="muted">Short sessions are fine—every data point helps tune the economy.</div>
						</div>
						<div class="section-nav">
							<a href="#/home">Back to home</a>
							<a href="#/about">About</a>
						</div>
					</div>
				</div>
				<div class="split-grid">
					<div class="card">
						<div class="label">What to test</div>
						<ul class="muted" style="margin:0.5rem 0 0; padding-left:1.2rem;">
							<li>Clarity of the core loop.</li>
							<li>Faucet pacing vs. star price growth.</li>
							<li>Perceived late-season scarcity.</li>
						</ul>
					</div>
					<div class="card">
						<div class="label">Suggested cadence</div>
						<div class="muted" style="margin-top:0.5rem;">Play 10–20 minutes per day and leave feedback in-app.</div>
					</div>
				</div>
			</div>
		</section>

		<section id="view-leaderboard" class="view">
			<div class="section-stack">
				<div class="card hero-card">
					<div class="card-header">
						<div>
							<div class="label">Leaderboard</div>
							<h2 style="margin:0.35rem 0 0;">Season rankings with bots labeled.</h2>
							<div class="muted">Server-authoritative ordering with stable tiebreakers.</div>
						</div>
						<div class="section-nav">
							<a href="#/home">Back to home</a>
						</div>
					</div>
				</div>

				<div class="card">
					<div class="row" style="margin-top:0.5rem;">
						<input id="leaderboard-search" placeholder="Search username or display name" />
						<select id="leaderboard-sort">
							<option value="stars_desc">Stars (high → low)</option>
							<option value="stars_asc">Stars (low → high)</option>
							<option value="coins_spent_desc">Coins spent (high → low)</option>
							<option value="coins_spent_asc">Coins spent (low → high)</option>
							<option value="last_star_time_asc">Last star time (earlier first)</option>
							<option value="created_at_asc">Created at (oldest first)</option>
						</select>
						<select id="leaderboard-page-size">
							<option value="25">25 / page</option>
							<option value="50" selected>50 / page</option>
							<option value="100">100 / page</option>
						</select>
					</div>
					<div class="row" style="margin-top:0.5rem;">
						<label class="label"><input type="checkbox" id="leaderboard-include-bots" checked /> Include bots</label>
						<label class="label"><input type="checkbox" id="leaderboard-bot-only" /> Bot-only</label>
						<button id="leaderboard-apply" class="primary">Apply</button>
					</div>
				</div>

				<div id="leaderboard-results" class="stack"></div>
				<div class="row" style="justify-content:space-between; margin-top:0.5rem;">
					<button id="leaderboard-prev">Previous</button>
					<span id="leaderboard-page" class="label"></span>
					<button id="leaderboard-next">Next</button>
				</div>
			</div>
		</section>

		<section id="view-signup" class="view">
			<div class="section-stack" style="max-width: 560px;">
				<div class="card hero-card">
					<div class="label">Create account</div>
					<h2 style="margin:0.35rem 0 0;">Join the season in minutes.</h2>
					<div class="muted">All economy logic is enforced server-side.</div>
				</div>
				<div class="card">
					<div class="stack">
						<input id="signup-username" placeholder="Username" />
						<input id="signup-display-name" placeholder="Display name" />
						<input id="signup-email" placeholder="Email" />
						<input id="signup-password" type="password" placeholder="Password" />
						<button class="primary" id="signup-btn">Sign up</button>
						<div class="label"><a href="#/home">Back to login</a></div>
						<div id="signup-toast" class="toast" style="display:none;"></div>
					</div>
				</div>
			</div>
		</section>

		<section id="view-reset" class="view">
			<div class="section-stack" style="max-width: 560px;">
				<div class="card hero-card">
					<div class="label">Account recovery</div>
					<h2 style="margin:0.35rem 0 0;">Reset access securely.</h2>
					<div class="muted">Reset tokens are validated on the server.</div>
				</div>
				<div class="card">
					<div class="stack">
						<div class="label">Request reset link</div>
						<input id="reset-identifier" placeholder="Email or username" />
						<button class="primary" id="reset-request-btn">Send reset email</button>
						<div id="reset-request-status" class="label"></div>
						<hr style="border:0; border-top:1px solid #2a2f55; width:100%;" />
						<div class="label">Have a token?</div>
						<input id="reset-token" placeholder="Reset token" />
						<input id="reset-new-password" type="password" placeholder="New password" />
						<button class="primary" id="reset-confirm-btn">Reset password</button>
						<div id="reset-confirm-status" class="label"></div>
						<div class="label"><a href="#/home">Back to login</a></div>
					</div>
				</div>
			</div>
		</section>

		<section id="view-moderator" class="view">
			<div class="section-stack">
				<div class="card hero-card">
					<div class="card-header">
						<div>
							<div class="label">Profile moderation</div>
							<h2 style="margin:0.35rem 0 0;">View and edit profiles with server authority.</h2>
							<div class="muted">Moderators edit user profiles. Admins can freeze or delete accounts.</div>
						</div>
						<div class="section-nav">
							<a href="#/home">Back to game</a>
						</div>
					</div>
				</div>

				<div class="card" id="moderator-content" data-collapsible="true" style="display:none;">
					<div class="card-toggle">
						<div class="label">Find profile</div>
						<button class="toggle-btn" type="button">Hide</button>
					</div>
					<div class="card-body">
						<div class="row" style="margin-top:0.5rem;">
							<input id="mod-username-view" placeholder="Username" />
							<button id="mod-load-view" class="primary">Load</button>
						</div>
						<div id="mod-status-view" class="label"></div>
					</div>
				</div>

				<div class="card" id="moderator-profile" data-collapsible="true" style="display:none;">
					<div class="card-toggle">
						<div class="label">Profile details</div>
						<button class="toggle-btn" type="button">Hide</button>
					</div>
					<div class="card-body">
						<div class="row" style="margin-top:0.5rem;">
							<input id="mod-display-name-view" placeholder="Display name" />
							<button id="mod-save-view" class="primary">Update</button>
						</div>
						<div class="row" style="margin-top:0.5rem;">
							<input id="mod-email-view" placeholder="Email" />
							<input id="mod-pronouns-view" placeholder="Pronouns" />
							<input id="mod-location-view" placeholder="Location" />
						</div>
						<div class="row" style="margin-top:0.5rem;">
							<input id="mod-website-view" placeholder="Website" />
							<input id="mod-avatar-view" placeholder="Avatar URL" />
						</div>
						<textarea id="mod-bio-view" rows="3" placeholder="Bio"></textarea>
					</div>
				</div>

				<div class="card" id="mod-no-access" style="display:none;">
					<div class="label">Not authorized</div>
					<div class="label">You need a moderator or admin account to view this page.</div>
				</div>
			</div>

			<div class="card collapsed" id="mod-admin-actions" data-collapsible="true" style="display:none;">
				<div class="card-toggle">
					<div class="label">Admin actions</div>
					<button class="toggle-btn" type="button">Show</button>
				</div>
				<div class="card-body">
					<div class="muted">Admin-only. Actions apply to the loaded profile.</div>
					<div class="row" style="margin-top:0.5rem;">
						<input id="mod-ip-whitelist" placeholder="IP to whitelist" />
						<input id="mod-ip-max" type="number" min="1" max="6" placeholder="Max accounts" />
						<button id="mod-ip-whitelist-btn" class="primary">Whitelist IP</button>
					</div>
					<div class="row" style="margin-top:0.5rem;">
						<button id="mod-freeze" class="danger">Freeze account</button>
						<button id="mod-unfreeze">Unfreeze account</button>
						<button id="mod-delete" class="danger">Delete account</button>
					</div>
					<div id="mod-admin-status" class="label"></div>
				</div>
			</div>
		</section>
	</main>

	<div class="footer">Made by AI</div>

	<script>
const authStatus = document.getElementById("auth-status");
const authForms = document.getElementById("auth-forms");
const logoutBtn = document.getElementById("logout-btn");
const profileName = document.getElementById("profile-name");
const profileRole = document.getElementById("profile-role");
const profileDisplay = document.getElementById("profile-display");
const profileEmail = document.getElementById("profile-email");
const profilePronouns = document.getElementById("profile-pronouns");
const profileLocation = document.getElementById("profile-location");
const profileWebsite = document.getElementById("profile-website");
const profileAvatar = document.getElementById("profile-avatar");
const profileAvatarImg = document.getElementById("profile-avatar-img");
const profileBio = document.getElementById("profile-bio");
const seasonSnapshot = document.getElementById("season-snapshot");
const profileSave = document.getElementById("profile-save");
const playerPanels = document.getElementById("player-panels");
const coinsDiv = document.getElementById("profile-coins");
const starsDiv = document.getElementById("profile-stars");
const onboarding = document.getElementById("onboarding");
const actionsCard = document.getElementById("actions-card");
const whitelistRequestCard = document.getElementById("whitelist-request-card");
const actionsStatus = document.getElementById("actions-status");
const toast = document.getElementById("toast");
const statPill = document.getElementById("stat-pill");
const notificationPanel = document.getElementById("notification-panel");
const notificationCount = document.getElementById("notification-count");
const notificationUnreadList = document.getElementById("notification-unread");
const notificationReadList = document.getElementById("notification-read");
const notificationHideBtn = document.getElementById("notification-hide");
const signupLink = document.getElementById("signup-link");
const moderatorLink = document.getElementById("moderator-link");
const liveStatus = document.getElementById("live-status");
const seasonRemaining = document.getElementById("season-remaining");
const seasonStarPrice = document.getElementById("season-star-price");
const seasonCoins = document.getElementById("season-coins");
const seasonEmission = document.getElementById("season-emission");
const seasonNextEmission = document.getElementById("season-next-emission");
const seasonTitle = document.getElementById("season-title");
const seasonStatus = document.getElementById("season-status");
const heroSeasonId = document.getElementById("hero-season-id");
const heroSeasonRemaining = document.getElementById("hero-season-remaining");
const heroStarPrice = document.getElementById("hero-star-price");
const heroInflation = document.getElementById("hero-inflation");
const leaderboardResults = document.getElementById("leaderboard-results");
const leaderboardPageLabel = document.getElementById("leaderboard-page");

const views = Array.from(document.querySelectorAll(".view"));
const viewMap = {
	home: "view-home",
	about: "view-about",
	playtest: "view-playtest",
	leaderboard: "view-leaderboard",
	signup: "view-signup",
	reset: "view-reset",
	moderator: "view-moderator"
};

let playerCoins = 0;
let playerStars = 0;
let currentUser = null;
let homeInitialized = false;
let moderatorInitialized = false;
let signupInitialized = false;
let resetInitialized = false;
let leaderboardInitialized = false;
let playerRefreshInterval = null;
let seasonRefreshInterval = null;
let notificationRefreshInterval = null;
let activityPingInterval = null;
let liveEventSource = null;
const ALPHA_SEASON_ID = "season-1";
const bulkStarMax = 5;
let leaderboardPage = 1;

function apiFetch(url, options = {}) {
	return fetch(url, {
		...options,
		headers: {
			"Content-Type": "application/json",
			...(options.headers || {})
		},
		credentials: "include"
	});
}

async function track(eventType, payload) {
	try {
		await apiFetch("/telemetry", {
			method: "POST",
			body: JSON.stringify({ eventType, payload })
		});
	} catch (e) {}
}

function formatRemaining(seconds) {
	if (seconds <= 0) return "Ended";
	const days = Math.floor(seconds / 86400);
	const hours = Math.floor((seconds % 86400) / 3600);
	const minutes = Math.floor((seconds % 3600) / 60);
	if (days > 0) return `${days}d ${hours}h`;
	if (hours > 0) return `${hours}h ${minutes}m`;
	return `${minutes}m`;
}

function updateLiveStatus(state, message) {
	if (!liveStatus) return;
	liveStatus.classList.remove("offline", "reconnecting");
	if (state === "offline") {
		liveStatus.classList.add("offline");
		liveStatus.innerText = message || "Offline";
		return;
	}
	if (state === "reconnecting") {
		liveStatus.classList.add("reconnecting");
		liveStatus.innerText = message || "Reconnecting";
		return;
	}
	liveStatus.innerText = message || "Live updates";
}

function updateSeasonSnapshot(season) {
	if (!season) return;
	if (seasonTitle) seasonTitle.innerText = "Season 1";
	if (seasonRemaining) seasonRemaining.innerText = formatRemaining(season.secondsRemaining || 0);
	if (seasonStarPrice) seasonStarPrice.innerText = `${season.currentStarPrice} coins`;
	if (seasonCoins) seasonCoins.innerText = `${season.coinsInCirculation} coins`;
	if (seasonEmission) seasonEmission.innerText = `${(season.coinEmissionPerMinute || 0).toFixed(2)} / min`;
	if (seasonNextEmission) seasonNextEmission.innerText = `${season.nextEmissionInSeconds || 0}s`;
	if (heroSeasonId) heroSeasonId.innerText = "Season 1";
	if (heroSeasonRemaining) heroSeasonRemaining.innerText = formatRemaining(season.secondsRemaining || 0);
	if (heroStarPrice) heroStarPrice.innerText = `${season.currentStarPrice} coins`;
	if (heroInflation) heroInflation.innerText = `${(season.coinEmissionPerMinute || 0).toFixed(2)} / min`;
	if (seasonStatus) {
		seasonStatus.innerText = season.secondsRemaining > 0 ? "Active" : "Ended";
	}
}

function updateSeasonCard(season) {
	if (!season) return;
	const card = document.querySelector(`[data-season-id="${season.seasonId}"]`);
	if (!card) return;
	const remainingEl = card.querySelector("[data-season-remaining]");
	const priceEl = card.querySelector("[data-season-price]");
	const coinsEl = card.querySelector("[data-season-coins]");
	const emissionEl = card.querySelector("[data-season-emission]");
	if (remainingEl) remainingEl.innerText = formatRemaining(season.secondsRemaining || 0);
	if (priceEl) priceEl.innerText = `${season.currentStarPrice} coins`;
	if (coinsEl) coinsEl.innerText = `${season.coinsInCirculation} coins`;
	if (emissionEl) emissionEl.innerText = `${(season.coinEmissionPerMinute || 0).toFixed(2)} / min`;
}

function applyLiveSnapshot(payload) {
	if (!payload || !payload.season) return;
	updateSeasonSnapshot(payload.season);
	updateSeasonCard(payload.season);
	if (payload.authenticated && typeof payload.playerCoins === "number" && typeof payload.playerStars === "number") {
		playerCoins = payload.playerCoins;
		playerStars = payload.playerStars;
		coinsDiv.innerText = `Coins: ${playerCoins}`;
		starsDiv.innerText = `Stars: ${playerStars}`;
		statPill.innerText = `${playerCoins} coins · ${playerStars} stars`;
	}
}

function connectLiveStream() {
	if (liveEventSource) return;
	try {
		liveEventSource = new EventSource("/events");
		liveEventSource.addEventListener("snapshot", (event) => {
			try {
				const payload = JSON.parse(event.data);
				applyLiveSnapshot(payload);
				updateLiveStatus("live", "Live updates");
			} catch (e) {}
		});
		liveEventSource.onopen = () => updateLiveStatus("live", "Live updates");
		liveEventSource.onerror = () => updateLiveStatus("reconnecting", "Reconnecting");
	} catch (e) {
		updateLiveStatus("offline", "Offline");
	}
}

function disconnectLiveStream() {
	if (liveEventSource) {
		liveEventSource.close();
		liveEventSource = null;
	}
	updateLiveStatus("offline", "Offline");
}

async function loadAuth() {
	const res = await apiFetch("/auth/me");
	const data = await res.json();
	if (!data.ok) {
		currentUser = null;
		authStatus.innerText = "Log in to save your profile.";
		authForms.style.display = "block";
		logoutBtn.style.display = "none";
		playerPanels.style.display = "none";
		seasonSnapshot.style.display = "none";
		actionsCard.style.display = "none";
		whitelistRequestCard.style.display = "none";
		statPill.style.display = "none";
		signupLink.style.display = "inline";
		moderatorLink.style.display = "none";
		notificationPanel.style.display = "none";
		notificationUnreadList.innerHTML = "";
		notificationReadList.innerHTML = "";
		notificationCount.style.display = "none";
		document.getElementById("seasons").style.display = "none";
		document.getElementById("locked-message").innerText = "Log in to access seasons.";
		connectLiveStream();
		return;
	}

	currentUser = data;
	authStatus.innerText = `Logged in as ${data.displayName}`;
	authForms.style.display = "none";
	logoutBtn.style.display = "block";
	profileName.innerText = `@${data.username}`;
	profileRole.innerText = `Role: ${data.role || "user"}`;
	profileDisplay.value = data.displayName;
	await loadProfile();
	playerPanels.style.display = "grid";
	seasonSnapshot.style.display = "block";
	actionsCard.style.display = "block";
	whitelistRequestCard.style.display = "block";
	statPill.style.display = "inline-flex";
	signupLink.style.display = "none";
	moderatorLink.style.display = (data.isModerator || data.isAdmin) ? "inline" : "none";
	document.getElementById("seasons").style.display = "grid";
	document.getElementById("locked-message").innerText = "";
}

notificationHideBtn.addEventListener("click", () => {
	notificationPanel.style.display = "none";
});

async function pingActivity() {
	if (!currentUser) return;
	try {
		await apiFetch("/activity", { method: "POST", body: JSON.stringify({}) });
	} catch (e) {}
}

function startActiveLoops() {
	if (playerRefreshInterval || seasonRefreshInterval || notificationRefreshInterval || activityPingInterval) {
		return;
	}
	refreshPlayer();
	loadSeasons();
	refreshNotifications();
	pingActivity();
	connectLiveStream();
	playerRefreshInterval = setInterval(() => {
		if (currentUser) refreshPlayer();
	}, 10000);
	seasonRefreshInterval = setInterval(() => {
		if (currentUser) loadSeasons();
	}, 15000);
	notificationRefreshInterval = setInterval(() => {
		if (currentUser) refreshNotifications();
	}, 15000);
	activityPingInterval = setInterval(() => {
		if (currentUser) pingActivity();
	}, 20000);
}

function stopActiveLoops() {
	if (playerRefreshInterval) clearInterval(playerRefreshInterval);
	if (seasonRefreshInterval) clearInterval(seasonRefreshInterval);
	if (notificationRefreshInterval) clearInterval(notificationRefreshInterval);
	if (activityPingInterval) clearInterval(activityPingInterval);
	playerRefreshInterval = null;
	seasonRefreshInterval = null;
	notificationRefreshInterval = null;
	activityPingInterval = null;
	disconnectLiveStream();
}

function handleVisibility() {
	if (document.hidden) {
		stopActiveLoops();
		return;
	}
	if (currentUser) {
		startActiveLoops();
	}
}

async function refreshPlayer() {
	if (!currentUser) return;
	const res = await apiFetch("/player");
	if (res.status === 401) return;
	const data = await res.json();
	playerCoins = data.playerCoins || 0;
	playerStars = data.playerStars || 0;
	coinsDiv.innerText = `Coins: ${playerCoins}`;
	starsDiv.innerText = `Stars: ${playerStars}`;
	statPill.innerText = `${playerCoins} coins · ${playerStars} stars`;
}

async function loadProfile() {
	if (!currentUser) return;
	const res = await apiFetch("/profile");
	if (!res.ok) return;
	const data = await res.json();
	if (!data.ok) return;
	profileDisplay.value = data.displayName || "";
	profileEmail.value = data.email || "";
	profilePronouns.value = data.pronouns || "";
	profileLocation.value = data.location || "";
	profileWebsite.value = data.website || "";
	profileAvatar.value = data.avatarUrl || "";
	profileBio.value = data.bio || "";
	profileAvatarImg.src = data.avatarUrl || "https://placehold.co/64x64?text=User";
}

async function loadSeasons() {
	const res = await fetch("/seasons");
	const data = await res.json();
	const container = document.getElementById("seasons");
	container.innerHTML = "";
	const alphaSeason = data.seasons.find(season => season.seasonId === ALPHA_SEASON_ID);
	if (!alphaSeason) {
		container.innerHTML = "<div class='card'>Season unavailable.</div>";
		return;
	}

	[alphaSeason].forEach(season => {
		const div = document.createElement("div");
		const isJoined = Boolean(currentUser);
		const isThisSeasonJoined = isJoined;
		const starPrice = season.currentStarPrice;
		updateSeasonSnapshot(season);

		div.className = "card season-card";
		div.dataset.seasonId = season.seasonId;
		if (season.seasonId === data.recommendedSeasonId) {
			div.classList.add("recommended");
		}

		div.innerHTML = `
			<div class="season-card-header">
				<div>
					<div class="label">Season 1</div>
					<div class="stat-value"><span data-season-remaining>${formatRemaining(season.secondsRemaining)}</span> remaining</div>
				</div>
				${season.seasonId === data.recommendedSeasonId ? '<span class="badge accent">Recommended</span>' : ''}
			</div>
			<div class="season-card-grid">
				<div class="metric">
					<div class="label">Star price</div>
					<div class="stat-value" data-season-price>${starPrice} coins</div>
				</div>
				<div class="metric">
					<div class="label">Coins in circulation</div>
					<div class="stat-value" data-season-coins>${season.coinsInCirculation} coins</div>
				</div>
				<div class="metric">
					<div class="label">Inflation pressure</div>
					<div class="stat-value" data-season-emission>${(season.coinEmissionPerMinute || 0).toFixed(2)} / min</div>
				</div>
			</div>
			<div class="season-actions">
				${isThisSeasonJoined
					? `
						<div class="row" style="margin-top:0.35rem;">
							<label class="label">Qty</label>
							<input class="bulk-qty" type="number" min="1" max="${bulkStarMax}" value="1" />
							<button class="buy-star-btn primary">Buy Stars</button>
						</div>
						<div class="label bulk-quote"></div>
						<div class="label bulk-warning"></div>
						<div class="label bulk-breakdown"></div>
					`
					: "<div class='label'>Log in to join the season.</div>"
				}
			</div>
		`;

		const buyButton = div.querySelector(".buy-star-btn");
		if (buyButton) {
			const qtyInput = div.querySelector(".bulk-qty");
			const quoteEl = div.querySelector(".bulk-quote");
			const warningEl = div.querySelector(".bulk-warning");
			const breakdownEl = div.querySelector(".bulk-breakdown");
			let lastQuote = null;
			const refreshQuote = async () => {
				if (!qtyInput) return;
				const qty = Math.max(1, parseInt(qtyInput.value, 10) || 1);
				if (quoteEl) quoteEl.innerText = "";
				if (warningEl) warningEl.innerText = "";
				if (breakdownEl) breakdownEl.innerText = "";
				const res = await apiFetch("/buy-star/quote", {
					method: "POST",
					body: JSON.stringify({ seasonId: season.seasonId, quantity: qty })
				});
				const data = await res.json();
				if (!data.ok) {
					lastQuote = null;
					if (quoteEl) quoteEl.innerText = data.error || "Quote failed";
					return;
				}
				lastQuote = data;
				const perStarPrice = typeof data.finalStarPrice === "number"
					? data.finalStarPrice
					: (data.breakdown && data.breakdown.length > 0 ? data.breakdown[data.breakdown.length - 1].finalPrice : null);
				const totalCost = typeof data.totalCoinsSpent === "number" ? data.totalCoinsSpent : null;
				if (quoteEl) {
					if (totalCost != null && perStarPrice != null) {
						quoteEl.innerText = `Total cost: ${totalCost} coins · Per-star: ${perStarPrice} coins`;
					} else if (totalCost != null) {
						quoteEl.innerText = `Total cost: ${totalCost} coins`;
					} else if (perStarPrice != null) {
						quoteEl.innerText = `Per-star: ${perStarPrice} coins`;
					} else {
						quoteEl.innerText = "";
					}
				}
				if (warningEl) warningEl.innerText = data.warning || "";
				if (breakdownEl) breakdownEl.innerText = "";
			};
			if (qtyInput) {
				qtyInput.addEventListener("input", refreshQuote);
				refreshQuote();
			}

			buyButton.addEventListener("click", async () => {
				const qty = Math.max(1, parseInt(qtyInput?.value, 10) || 1);
				await refreshQuote();
				if (qty > 1) {
					const totalCost = lastQuote && typeof lastQuote.totalCoinsSpent === "number" ? lastQuote.totalCoinsSpent : null;
					const confirmMessage = totalCost != null
						? `Confirm purchase of ${qty} stars for ${totalCost} coins?`
						: `Confirm purchase of ${qty} stars?`;
					if (!confirm(confirmMessage)) {
						return;
					}
				}
				const res = await apiFetch("/buy-star", {
					method: "POST",
					body: JSON.stringify({ seasonId: season.seasonId, quantity: qty })
				});
				const data = await res.json();
				if (!data.ok) {
					setToast(data.error || "Purchase failed", "error");
					return;
				}
				playerCoins = data.playerCoins;
				playerStars = data.playerStars;
				coinsDiv.innerText = `Coins: ${playerCoins}`;
				starsDiv.innerText = `Stars: ${playerStars}`;
				statPill.innerText = `${playerCoins} coins · ${playerStars} stars`;
				const label = data.starsPurchased && data.starsPurchased > 1
					? `Bought ${data.starsPurchased} stars.`
					: "Star purchased.";
				setToast(label, "success");
				track("buy_star", { seasonId: season.seasonId, quantity: data.starsPurchased || 1 });
				refreshQuote();
			});
		}

		container.appendChild(div);
	});
}

function setToast(message, type) {
	toast.innerText = message;
	toast.className = `toast ${type || ""}`;
	toast.style.display = "block";
	setTimeout(() => {
		toast.style.display = "none";
	}, 2500);
}

function initLeaderboard() {
	leaderboardInitialized = true;
	document.getElementById("leaderboard-apply").addEventListener("click", () => {
		leaderboardPage = 1;
		loadLeaderboard();
	});
	document.getElementById("leaderboard-prev").addEventListener("click", () => {
		if (leaderboardPage > 1) {
			leaderboardPage -= 1;
			loadLeaderboard();
		}
	});
	document.getElementById("leaderboard-next").addEventListener("click", () => {
		leaderboardPage += 1;
		loadLeaderboard();
	});
	document.getElementById("leaderboard-search").addEventListener("keydown", (event) => {
		if (event.key === "Enter") {
			leaderboardPage = 1;
			loadLeaderboard();
		}
	});
}

async function loadLeaderboard() {
	if (!leaderboardResults) return;
	const params = new URLSearchParams();
	const searchValue = document.getElementById("leaderboard-search").value.trim();
	const includeBots = document.getElementById("leaderboard-include-bots").checked;
	const botOnly = document.getElementById("leaderboard-bot-only").checked;
	const sort = document.getElementById("leaderboard-sort").value;
	const pageSize = parseInt(document.getElementById("leaderboard-page-size").value, 10) || 50;

	if (searchValue) params.set("q", searchValue);
	params.set("includeBots", includeBots ? "true" : "false");
	params.set("botOnly", botOnly ? "true" : "false");
	params.set("sort", sort);
	params.set("page", `${leaderboardPage}`);
	params.set("pageSize", `${pageSize}`);

	const res = await apiFetch(`/leaderboard?${params.toString()}`);
	const data = await res.json();
	if (!data.results) {
		leaderboardResults.innerHTML = "<div class='card'>Unable to load leaderboard.</div>";
		return;
	}

	if (data.results.length === 0) {
		leaderboardResults.innerHTML = "<div class='card'>No results found.</div>";
		if (leaderboardPageLabel) leaderboardPageLabel.innerText = `Page ${data.page} of 1`;
		return;
	}

	const totalPages = Math.max(1, Math.ceil((data.total || 0) / data.pageSize));
	if (leaderboardPageLabel) leaderboardPageLabel.innerText = `Page ${data.page} of ${totalPages}`;

	leaderboardResults.innerHTML = data.results.map(entry => {
		const botBadge = entry.isBot ? `<span class="badge bot">BOT</span>` : "";
		const botProfile = entry.isBot && entry.botProfile ? `<div class="label">${entry.botProfile}</div>` : "";
		const lastStar = entry.lastStarAcquiredAt ? new Date(entry.lastStarAcquiredAt).toLocaleString() : "-";
		return `
			<div class="card">
				<div class="row" style="justify-content:space-between;">
					<div><strong>#${entry.rank}</strong> ${entry.displayName}</div>
					${botBadge}
				</div>
				<div class="label">Stars ${entry.stars} · Coins spent ${entry.coinsSpentLifetime}</div>
				<div class="label">Last star: ${lastStar}</div>
				${botProfile}
			</div>
		`;
	}).join("");
}

async function refreshNotifications() {
	if (!currentUser) {
		notificationPanel.style.display = "none";
		notificationUnreadList.innerHTML = "";
		notificationReadList.innerHTML = "";
		notificationCount.style.display = "none";
		return;
	}
	const res = await apiFetch("/notifications");
	const data = await res.json();
	if (!data.ok) {
		notificationPanel.style.display = "none";
		return;
	}
	const items = data.notifications || [];
	const unread = items.filter(item => !item.isRead);
	const read = items.filter(item => item.isRead);
	if (items.length === 0) {
		notificationPanel.style.display = "none";
		notificationUnreadList.innerHTML = "";
		notificationReadList.innerHTML = "";
		notificationCount.style.display = "none";
		return;
	}
	notificationPanel.style.display = "block";
	if (unread.length > 0) {
		notificationCount.style.display = "inline-flex";
		notificationCount.innerText = `${unread.length} unread`;
	} else {
		notificationCount.style.display = "none";
	}

	const renderItem = (item) => {
		const level = item.level || "info";
		const stateClass = item.isRead ? "read" : "unread";
		const safeLink = item.link || "#/home";
		return `
			<div class="notice clickable ${level} ${stateClass}" data-id="${item.id}" data-link="${safeLink}" data-read="${item.isRead}">
				<div>${item.message}</div>
				<div class="label">${new Date(item.createdAt).toLocaleString()}</div>
			</div>
		`;
	};

	notificationUnreadList.innerHTML = unread.length > 0
		? unread.map(renderItem).join("")
		: "<div class='label'>No unread notifications.</div>";
	notificationReadList.innerHTML = read.length > 0
		? read.map(renderItem).join("")
		: "<div class='label'>No read notifications.</div>";

	[...notificationPanel.querySelectorAll(".notice[data-id]")].forEach(item => {
		item.addEventListener("click", async () => {
			const id = parseInt(item.getAttribute("data-id"), 10);
			const link = item.getAttribute("data-link") || "#/home";
			const isRead = item.getAttribute("data-read") === "true";
			if (!isRead) {
				await apiFetch("/notifications/ack", {
					method: "POST",
					body: JSON.stringify({ ids: [id] })
				});
				await refreshNotifications();
			}
			if (link.startsWith("http")) {
				window.location.href = link;
				return;
			}
			if (link.startsWith("#/")) {
				location.hash = link;
				return;
			}
			if (link.startsWith("/")) {
				location.hash = `#${link}`;
				return;
			}
			location.hash = `#/${link}`;
		});
	});
}

function setView(viewId) {
	views.forEach(view => view.classList.remove("active"));
	const nextView = document.getElementById(viewId);
	if (nextView) {
		nextView.classList.add("active");
	}
}

function initCollapsibleCards() {
	if (initCollapsibleCards.initialized) return;
	initCollapsibleCards.initialized = true;
	const cards = Array.from(document.querySelectorAll(".card[data-collapsible='true']"));
	cards.forEach(card => {
		const toggleBtn = card.querySelector(".toggle-btn");
		const body = card.querySelector(".card-body");
		if (!toggleBtn || !body) return;
		toggleBtn.addEventListener("click", () => {
			const collapsed = card.classList.toggle("collapsed");
			toggleBtn.innerText = collapsed ? "Show" : "Hide";
		});
	});
}

function getRouteInfo() {
	const hash = location.hash.replace("#", "");
	if (!hash || hash === "/") {
		return { routeKey: "home", query: new URLSearchParams() };
	}
	const trimmed = hash.startsWith("/") ? hash.slice(1) : hash;
	const parts = trimmed.split("?");
	const routeKey = viewMap[parts[0]] ? parts[0] : "home";
	const query = new URLSearchParams(parts[1] || "");
	return { routeKey, query };
}

async function route() {
	const { routeKey, query } = getRouteInfo();
	await loadAuth();
	initCollapsibleCards();
	if (routeKey === "signup" && currentUser) {
		location.hash = "#/home";
		return;
	}
	setView(viewMap[routeKey]);
	if (routeKey === "home") {
		if (!homeInitialized) initHome();
		await refreshPlayer();
		if (currentUser && !document.hidden) {
			startActiveLoops();
		}
		return;
	}
	if (routeKey === "signup") {
		if (!signupInitialized) initSignup();
		return;
	}
	if (routeKey === "reset") {
		if (!resetInitialized) initReset();
		const token = query.get("token") || "";
		if (token) {
			document.getElementById("reset-token").value = token;
		}
		return;
	}
	if (routeKey === "moderator") {
		if (!moderatorInitialized) initModerator();
		await refreshModeratorView();
		return;
	}
	if (routeKey === "leaderboard") {
		if (!leaderboardInitialized) initLeaderboard();
		await loadLeaderboard();
		return;
	}
}

function initHome() {
	homeInitialized = true;
	document.getElementById("login-btn").addEventListener("click", async () => {
		const username = document.getElementById("username").value;
		const password = document.getElementById("password").value;
		if (!username || !password) {
			setToast("Enter username and password.", "error");
			return;
		}
		setToast("Logging in...", "success");
		try {
			const res = await apiFetch("/auth/login", {
				method: "POST",
				body: JSON.stringify({ username, password })
			});
			let data = null;
			try {
				data = await res.json();
			} catch (e) {
				setToast("Login failed (invalid response)", "error");
				return;
			}
			if (!data.ok) {
				setToast(data.error || "Login failed", "error");
				return;
			}
			await loadAuth();
			if (!currentUser) {
				setToast("Login failed (session not established)", "error");
				return;
			}
			await refreshPlayer();
			await loadSeasons();
			setToast("Logged in.", "success");
			if (!document.hidden) {
				startActiveLoops();
			}
			track("login", {});
		} catch (e) {
			setToast("Login failed (network error)", "error");
		}
	});

	logoutBtn.addEventListener("click", async () => {
		await apiFetch("/auth/logout", { method: "POST" });
		currentUser = null;
		stopActiveLoops();
		await loadAuth();
	});

	profileSave.addEventListener("click", async () => {
		const displayName = profileDisplay.value;
		const email = profileEmail.value;
		const res = await apiFetch("/profile", {
			method: "POST",
			body: JSON.stringify({
				displayName,
				email,
				bio: profileBio.value,
				pronouns: profilePronouns.value,
				location: profileLocation.value,
				website: profileWebsite.value,
				avatarUrl: profileAvatar.value
			})
		});
		const data = await res.json();
		if (!data.ok) {
			setToast(data.error || "Update failed", "error");
			return;
		}
		authStatus.innerText = `Logged in as ${data.displayName}`;
		if (profileAvatar.value.trim()) {
			profileAvatarImg.src = profileAvatar.value.trim();
		}
		setToast("Profile updated.", "success");
	});

	document.getElementById("claim-daily").addEventListener("click", async () => {
		const res = await apiFetch("/claim-daily", { method: "POST", body: JSON.stringify({}) });
		const data = await res.json();
		if (!data.ok) {
			actionsStatus.innerText = data.error || "Claim failed";
			setToast(actionsStatus.innerText, "error");
			return;
		}
		actionsStatus.innerText = `Daily claim: +${data.reward} coins`;
		setToast("Daily claim received.", "success");
		await refreshPlayer();
	});

	document.getElementById("claim-activity").addEventListener("click", async () => {
		const res = await apiFetch("/claim-activity", { method: "POST", body: JSON.stringify({}) });
		const data = await res.json();
		if (!data.ok) {
			actionsStatus.innerText = data.error || "Claim failed";
			setToast(actionsStatus.innerText, "error");
			return;
		}
		actionsStatus.innerText = `Activity claim: +${data.reward} coins`;
		setToast("Activity claim received.", "success");
		await refreshPlayer();
	});

	document.getElementById("whitelist-request-btn").addEventListener("click", async () => {
		const reason = document.getElementById("whitelist-reason").value.trim();
		const res = await apiFetch("/auth/request-whitelist", {
			method: "POST",
			body: JSON.stringify({ reason })
		});
		const data = await res.json();
		document.getElementById("whitelist-request-status").innerText = data.ok
			? "Request submitted for admin review."
			: (data.error || "Request failed");
	});

	document.getElementById("dismiss-hint").addEventListener("click", () => {
		localStorage.setItem("dismissedHint", "true");
		onboarding.style.display = "none";
	});

	if (localStorage.getItem("dismissedHint") !== "true") {
		onboarding.style.display = "block";
	}

	document.addEventListener("visibilitychange", handleVisibility);
	handleVisibility();
}

function initSignup() {
	signupInitialized = true;
	document.getElementById("signup-btn").addEventListener("click", async () => {
		const username = document.getElementById("signup-username").value;
		const password = document.getElementById("signup-password").value;
		const displayName = document.getElementById("signup-display-name").value;
		const email = document.getElementById("signup-email").value;
		const res = await apiFetch("/auth/signup", {
			method: "POST",
			body: JSON.stringify({ username, password, displayName, email })
		});
		const data = await res.json();
		const toast = document.getElementById("signup-toast");
		if (!data.ok) {
			toast.innerText = data.error || "Signup failed";
			toast.style.display = "block";
			return;
		}
		location.hash = "#/home";
	});
}

function initReset() {
	resetInitialized = true;
	document.getElementById("reset-request-btn").addEventListener("click", async () => {
		const identifier = document.getElementById("reset-identifier").value.trim();
		const res = await apiFetch("/auth/request-reset", {
			method: "POST",
			body: JSON.stringify({ identifier })
		});
		const data = await res.json();
		const status = document.getElementById("reset-request-status");
		status.innerText = data.ok ? "If the account exists, a reset email was sent." : (data.error || "Request failed");
	});

	document.getElementById("reset-confirm-btn").addEventListener("click", async () => {
		const token = document.getElementById("reset-token").value.trim();
		const newPassword = document.getElementById("reset-new-password").value;
		const res = await apiFetch("/auth/reset-password", {
			method: "POST",
			body: JSON.stringify({ token, newPassword })
		});
		const data = await res.json();
		const status = document.getElementById("reset-confirm-status");
		if (!data.ok) {
			status.innerText = data.error || "Reset failed";
			return;
		}
		status.innerText = "Password updated. You can log in now.";
		location.hash = "#/home";
	});
}

function initModerator() {
	moderatorInitialized = true;
	const profileCard = document.getElementById("moderator-profile");
	const adminActionsCard = document.getElementById("mod-admin-actions");
	const statusView = document.getElementById("mod-status-view");
	const adminStatus = document.getElementById("mod-admin-status");
	let loadedUsername = "";

	document.getElementById("mod-load-view").addEventListener("click", async () => {
		const username = document.getElementById("mod-username-view").value.trim();
		if (!username) {
			statusView.innerText = "Enter a username.";
			return;
		}
		const res = await apiFetch(`/moderator/profile?username=${encodeURIComponent(username)}`);
		const data = await res.json();
		if (!data.ok) {
			document.getElementById("mod-status-view").innerText = data.error || "Load failed.";
			return;
		}
		loadedUsername = data.username || username;
		document.getElementById("mod-display-name-view").value = data.displayName || "";
		document.getElementById("mod-email-view").value = data.email || "";
		document.getElementById("mod-pronouns-view").value = data.pronouns || "";
		document.getElementById("mod-location-view").value = data.location || "";
		document.getElementById("mod-website-view").value = data.website || "";
		document.getElementById("mod-avatar-view").value = data.avatarUrl || "";
		document.getElementById("mod-bio-view").value = data.bio || "";
		const roleLabel = data.role ? `Role: ${data.role}` : "";
		const frozenLabel = data.frozen ? " · Frozen" : "";
		document.getElementById("mod-status-view").innerText = roleLabel ? `Profile loaded. ${roleLabel}${frozenLabel}` : "Profile loaded.";
		if (profileCard) profileCard.style.display = "block";
		if (adminActionsCard) adminActionsCard.style.display = (currentUser && currentUser.isAdmin) ? "block" : "none";
		if (adminStatus) adminStatus.innerText = "";
		const isSelf = currentUser && currentUser.username && loadedUsername
			? currentUser.username.toLowerCase() === loadedUsername.toLowerCase()
			: false;
		const freezeBtn = document.getElementById("mod-freeze");
		const unfreezeBtn = document.getElementById("mod-unfreeze");
		const deleteBtn = document.getElementById("mod-delete");
		if (freezeBtn) freezeBtn.disabled = isSelf;
		if (unfreezeBtn) unfreezeBtn.disabled = isSelf;
		if (deleteBtn) deleteBtn.disabled = isSelf;
	});

	document.getElementById("mod-save-view").addEventListener("click", async () => {
		const username = document.getElementById("mod-username-view").value.trim();
		if (!username) {
			statusView.innerText = "Load a profile first.";
			return;
		}
		const displayName = document.getElementById("mod-display-name-view").value.trim();
		const email = document.getElementById("mod-email-view").value.trim();
		const pronouns = document.getElementById("mod-pronouns-view").value.trim();
		const location = document.getElementById("mod-location-view").value.trim();
		const website = document.getElementById("mod-website-view").value.trim();
		const avatarUrl = document.getElementById("mod-avatar-view").value.trim();
		const bio = document.getElementById("mod-bio-view").value.trim();
		const res = await apiFetch("/moderator/profile", {
			method: "POST",
			body: JSON.stringify({ username, displayName, email, pronouns, location, website, avatarUrl, bio })
		});
		const data = await res.json();
		document.getElementById("mod-status-view").innerText = data.ok ? "Profile updated." : (data.error || "Update failed.");
	});

	document.getElementById("mod-ip-whitelist-btn").addEventListener("click", async () => {
		if (!currentUser || !currentUser.isAdmin) {
			adminStatus.innerText = "Admin access required.";
			return;
		}
		if (!loadedUsername) {
			adminStatus.innerText = "Load a profile first.";
			return;
		}
		const ip = document.getElementById("mod-ip-whitelist").value.trim();
		const maxAccountsRaw = parseInt(document.getElementById("mod-ip-max").value, 10);
		const maxAccounts = Number.isNaN(maxAccountsRaw) ? 2 : maxAccountsRaw;
		if (!ip) {
			adminStatus.innerText = "Enter an IP address to whitelist.";
			return;
		}
		const res = await apiFetch("/admin/ip-whitelist", {
			method: "POST",
			body: JSON.stringify({ ip, maxAccounts, action: "set" })
		});
		const data = await res.json();
		adminStatus.innerText = data.ok ? `Whitelisted ${ip} (max ${maxAccounts}).` : (data.error || "Whitelist failed.");
	});

	document.getElementById("mod-freeze").addEventListener("click", async () => {
		if (!currentUser || !currentUser.isAdmin) {
			adminStatus.innerText = "Admin access required.";
			return;
		}
		const username = document.getElementById("mod-username-view").value.trim();
		if (!username) {
			adminStatus.innerText = "Load a profile first.";
			return;
		}
		if (!confirm(`Freeze account ${username}?`)) {
			return;
		}
		const res = await apiFetch("/admin/profile-actions", {
			method: "POST",
			body: JSON.stringify({ username, action: "freeze" })
		});
		const data = await res.json();
		adminStatus.innerText = data.ok ? "Account frozen." : (data.error || "Freeze failed.");
	});

	document.getElementById("mod-unfreeze").addEventListener("click", async () => {
		if (!currentUser || !currentUser.isAdmin) {
			adminStatus.innerText = "Admin access required.";
			return;
		}
		const username = document.getElementById("mod-username-view").value.trim();
		if (!username) {
			adminStatus.innerText = "Load a profile first.";
			return;
		}
		if (!confirm(`Unfreeze account ${username}?`)) {
			return;
		}
		const res = await apiFetch("/admin/profile-actions", {
			method: "POST",
			body: JSON.stringify({ username, action: "unfreeze" })
		});
		const data = await res.json();
		adminStatus.innerText = data.ok ? "Account unfrozen." : (data.error || "Unfreeze failed.");
	});

	document.getElementById("mod-delete").addEventListener("click", async () => {
		if (!currentUser || !currentUser.isAdmin) {
			adminStatus.innerText = "Admin access required.";
			return;
		}
		const username = document.getElementById("mod-username-view").value.trim();
		if (!username) {
			adminStatus.innerText = "Load a profile first.";
			return;
		}
		if (!confirm(`Delete account ${username}? This cannot be undone.`)) {
			return;
		}
		const confirmText = prompt("Type DELETE to confirm account deletion:");
		if (confirmText !== "DELETE") {
			adminStatus.innerText = "Deletion canceled.";
			return;
		}
		const res = await apiFetch("/admin/profile-actions", {
			method: "POST",
			body: JSON.stringify({ username, action: "delete" })
		});
		const data = await res.json();
		adminStatus.innerText = data.ok ? "Account deleted." : (data.error || "Delete failed.");
	});

}

async function refreshModeratorView() {
	const res = await apiFetch("/auth/me");
	const data = await res.json();
	if (!data.ok || (!data.isModerator && !data.isAdmin)) {
		document.getElementById("mod-no-access").style.display = "block";
		document.getElementById("moderator-content").style.display = "none";
		document.getElementById("moderator-profile").style.display = "none";
		document.getElementById("mod-admin-actions").style.display = "none";
		return false;
	}
	document.getElementById("mod-no-access").style.display = "none";
	document.getElementById("moderator-content").style.display = "block";
	document.getElementById("moderator-profile").style.display = "none";
	document.getElementById("mod-admin-actions").style.display = "none";
	return true;
}

window.addEventListener("error", (event) => {
	setToast(`Error: ${event.message}`, "error");
});

window.addEventListener("unhandledrejection", (event) => {
	setToast("Error: unexpected failure", "error");
});

window.addEventListener("hashchange", () => {
	route().catch((err) => {
		const message = err && err.message ? err.message : "route failed";
		setToast(`Error: ${message}`, "error");
	});
});

route().catch((err) => {
	const message = err && err.message ? err.message : "route failed";
	setToast(`Error: ${message}`, "error");
});
	</script>
</body>
</html>
